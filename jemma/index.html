<!DOCTYPE html>
<html>
  <head>
    <title>Ohjelmoinnin perusteet ja Ohjelmoinnin jatkokurssi, syksy 2018 | </title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">

    <link href="../stylesheets/styles-9fe27d3a.css" rel="stylesheet" />

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/styles/xcode.min.css">

    <link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.1/cookieconsent.min.css" />

    <link rel="stylesheet" href="https://materiaalit.github.io/code-states-visualizer-cdn/app.css" />
    <link rel="stylesheet" href="https://materiaalit.github.io/typonator-cdn/app.css" />
    <link rel="stylesheet" href="https://crowdsorcerer.testmycode.io/dist/app.css" />
    <link rel="stylesheet" href="https://materiaalit.github.io/pdf-slideshow-cdn/app.css" />

      <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-47575342-8', 'auto');
  ga('set', 'anonymizeIp', true);
  ga('send', 'pageview');
</script>

  </head>
  <body>
    <div class="main-wrapper">
      <div class="header-wrapper">
        <div class="browser-support-warning" id="browser-support-warning" style="display: none;">
  Kaikki tämän materiaalin osat eivät välttämättä tuo nykyistä selaintasi. Voisitko harkita vaihtamista <a href="https://www.google.com/chrome/browser/desktop/" target="_blank" rel="noopener">Chrome</a> tai <a href="https://www.mozilla.org/en-US/firefox/new/" target="_blank" rel="noopener">Firefox</a> selaimeen?
  <span class="browser-support-warning__close">Selvä!</span>
</div>


        <nav class="navbar navbar-light bg-white">
  <a class="navbar-brand" href="http://mooc.fi" alt="MOOC" target="_blank" rel="noopener">
    <span class="icon-mooc"></span>
  </a>

  <ul class="nav navbar-nav hidden-md-down">
      <li class="nav-item ">
        <a href="../" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=index.html&gt;')">Johdanto</a>
      </li>
      <li class="nav-item ">
        <a href="../part1/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part1.html&gt;')">Osa 1</a>
      </li>
      <li class="nav-item ">
        <a href="../part2/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part2.html&gt;')">Osa 2</a>
      </li>
      <li class="nav-item ">
        <a href="../part3/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part3.html&gt;')">Osa 3</a>
      </li>
      <li class="nav-item ">
        <a href="../part4/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part4.html&gt;')">Osa 4</a>
      </li>
      <li class="nav-item ">
        <a href="../part5/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part5.html&gt;')">Osa 5</a>
      </li>
      <li class="nav-item ">
        <a href="../part6/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part6.html&gt;')">Osa 6</a>
      </li>
      <li class="nav-item ">
        <a href="../part7/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part7.html&gt;')">Osa 7</a>
      </li>
      <li class="nav-item ">
        <a href="../part7-x/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part7-x.html&gt;')">Osa 7.X</a>
      </li>
      <li class="nav-item ">
        <a href="../part8/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part8.html&gt;')">Osa 8</a>
      </li>
      <li class="nav-item ">
        <a href="../part9/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part9.html&gt;')">Osa 9</a>
      </li>
      <li class="nav-item ">
        <a href="../part10/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part10.html&gt;')">Osa 10</a>
      </li>
      <li class="nav-item ">
        <a href="../part11/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part11.html&gt;')">Osa 11</a>
      </li>
  </ul>

  <div class="float-xs-right navbar__buttons">
    <div class="dropdown" id="mobile-nav-dropdown">
      <button class="btn btn-secondary dropdown-toggle navbar__mobile-nav-toggle" data-toggle="dropdown">
        <i class="fa fa-bars"></i>
      </button>

      <div class="dropdown-menu">
      </div>
    </div>

    <a href="https://tmc.mooc.fi" target="_blank" rel="noopener" class="btn btn-secondary">
      <span class="hidden-md-down">Palautukset</span>
      <i class="fa fa-arrow-circle-up hidden-lg-up"></i>
    </a>

    <a href="https://t.me/ohjelmointi_s18" target="_blank" rel="noopener" class="btn btn-secondary">
      <span class="hidden-md-down">Chat</span>
      <i class="fa fa-comments hidden-lg-up"></i>
    </a>

    <button class="btn btn-secondary" id="table-of-contents-toggle">
      <span class="hidden-md-down">Sisällysluettelo</span>
      <i class="fa fa-ellipsis-h hidden-lg-up"></i>
    </button>

    <button class="btn btn-primary" id="tmc-login-toggle">Kirjaudu sisään</button>
  </div>
</nav>

      </div>

      <div class="content-wrapper">
        <div class="container material" id="material">

          

<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Satunnaiskävely</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Oletetaan, että henkilö aloittaa kävelynsä pisteestä (0, 0). Tietämättä maailmasta enempää, onko mahdollista, että henkilö voi kulkea pisteeseen (20, 20)?
  </p>

  <p>
    Kursseilla tietorakenteet ja algoritmit sekä johdatus tekoälyyn tarkastellaan muunmuassa reitinhakualgoritmeja, joiden avulla voidaan selvittää nopeimpia reittejä annettujen pisteiden välillä. Tässä tarkastelemme ongelmaa hieman erilaisen menetelmän avulla ja tutustumme satunnaiskävelyyn (satunnaiskulku, random walk).
  </p>

  <p>
    Satunnaiskävelyssä todennäköisyydet liikkeelle ovat näennäisesti satunnaisia. Toteutettavassa tapauksessamme henkilö liikkuu seuraavasti: 20% todennäköisyydellä hän pysyy paikallaan, 20% todennäköisyydellä hän liikkuu oikealle, 20% todennäköisyydellä hän liikkuu vasemmalle, 20% todennäköisyydellä hän liikkuu ylös, ja 20% todennäköisyydellä hän liikkuu alas.
  </p>

  <p>
    Jos algoritmi ei ole saavuttanut pistettä (20, 20) hyvin ison askelmäärän jälkeen, voimme ehdottaa, että pisteeseen (20, 20) ei ole pääsyä.
  </p>

  <p>
    Tehtäväpohjassa on annettu satunnaiskävelyn piirtämistä varten luotu ohjelma, missä kaksiulotteista maailmaa mallinnetaan kahden sisäkkäisen HashMap-tietorakenteen avulla seuraavasti<code>HashMap&lt;Integer, HashMap&lt;Integer, Double&gt;&gt; taulukko</code>. Koordinaatissa 0, 0 olevaan arvoon pääsee käsiksi kutsumalla <code>taulukko.get(0).get(0)</code>.
  </p>

  <p>
    Tehtäväpohjassa on lisäksi mallinnettu tilannetta, missä jokainen askel jättää hiljalleen haihtuvan jäljen.
  </p>

  <p>
    Tehtävänäsi on tutustua ohjelmaan ja lisätä siihen toiminnallisuus, missä jokainen askel on satunnainen. Henkilön askelten tulee tapahtua seuraavasti: 20% todennäköisyydellä henkilö pysyy paikallaan, 20% todennäköisyydellä henkilö liikkuu oikealle, 20% todennäköisyydellä henkilö liikkuu vasemmalle, 20% todennäköisyydellä henkilö liikkuu ylös, ja 20% todennäköisyydellä henkilö liikkuu alas.
  </p>

  <p>
    Alla on kuvakaappaus eräästä satunnaiskävelystä.
  </p>

  <img src="../img/satunnaiskavely-f18cb75d.gif" alt="Esimerkki (lyhyestä) satunnaiskävelystä)"/>

  <p>
    TODO: selvennä
  </p>
  <p>
    Vaikka <a href="https://en.wikipedia.org/wiki/Random_walk" target="_blank" norel>Random walk</a> -menetelmä tuntuu hyvin yksinkertaiselta, sillä on monia sovelluksia. Sitä käytetään muunmuassa molekyylien satunnaisen liikkeen mallintamisessa, osakkeiden hintojen muutosten mallintamisessa, ja geenien satunnaisissa muutoksissa.
  </p>

  <p>
    Tehtävään ei ole testejä -- palauta se kun se toimii halutusti.
  </p>



    </div>
  </div>
</div>




<h1 class="material-heading">
    Tehtäväpohjien rakenne ja Maven

</h1>

<p>
  Ohjelmoinnin jatkokurssista lähtien kurssin tehtäväpohjat käyttävät <a href="https://maven.apache.org/" target="_blank" norel>Maven</a>-nimistä projektinhallintatyövälinettä. Kyseinen työväline helpottaa kurssin tehtävien mukana tuotavien kirjastojen hallintaa. Tehtäviin tämä vaikuttaa siten, että niiden kansiorakenne muuttuu hieman. 
</p>

<p>
  Jatkossa tehtävän juurikansiossa on tiedosto pom.xml, joka kuvaa tehtäväpohjan rakenteen. Kansio <code>src</code> sisältää kansiot <code>main</code> ja <code>test</code>, jotka sisältävät lähdekooditiedostot sekä testitiedostot.

</p>


<h2 class="material-heading">
    Metodit ja ohjelman nimentä

</h2>

<p>
  Tarkastellaan ohjelman nimentää ja selventämistä vielä metodien avulla. 
</p>

<p>
  <em>
    Vuosi on karkausvuosi, jos se on jaollinen 4:llä. Kuitenkin jos vuosi on jaollinen 100:lla, se on karkausvuosi vain silloin, kun se on jaollinen myös 400:lla.
  </em>
</p>



<p>
  TODO: muutama esimerkki eri ääripäistä -- yhdessä ohjelmassa ei ole lainkaan metodeja, toisessa ohjelma koostuu pelkistä metodeista.
</p>

<pre class="sh_java code-highlight"><code>public static boolean jaollinen(int luku, int luvulla) {
    return luku % luvulla == 0;

    // tai 
    if (luku % luvulla == 0) {
      return true;
    }

    return false;
}
</code></pre>


<pre class="sh_java code-highlight"><code>public static boolean ei(boolean arvo) {
    return !arvo;

    // tai 
    if (arvo == true) {
      return false;
    }

    return true;

    // tai
    if (arvo) {
      return false;
    }

    return true;
}
</code></pre>


<pre class="sh_java code-highlight"><code>if(ei(jaollinen(luku, 400))) {
  // heh
}
</code></pre>



<pre>
$/Osa08_01.SamaPaivays$ tree
.
├── pom.xml
└── src
    ├── main
    │   └── java
    │       ├── Paaohjelma.java
    │       └── Paivays.java
    └── test
        └── java
            └── PaivaysTest.java

</pre>


<p>
  Ohjelmien toiminta ei käytännössä juurikaan muutu. Toisin kuin ennen, ohjelmien tarvitsemat kirjastot eivät kuitenkaan tule tehtäväpohjan mukana, vaan Mavenilta tulee pyytää tarvittaessa niiden lataamista. Tämä onnistuu klikkaamalla tehtäväpohjan Dependencies-kuvaketta Projects-välilehdellä ja valitsemalla "Download declared dependencies."
</p>

<img src="../img/maven-1-631fec34.png"/>

<br/>

<p>
  Riippuen tietokoneesi käyttöjärjestelmästä, on mahdollista, että joudut lisäämään Maven-ohjelmaan ajo-oikeudet kun sitä käytetään ensimmäistä kertaa. Windowsille ohjeita löytyy yleisesti ottaen googlettamalla ja mm. täältä: <a href="https://www.online-tech-tips.com/computer-tips/set-file-folder-permissions-windows/" target="_blank" norel>https://www.online-tech-tips.com/computer-tips/set-file-folder-permissions-windows/</a> -- myös pajassa neuvotaan tähän liittyen. 
</p>


<h2 class="material-heading">
    Ongelmia ja ratkaisuja

</h2>

<p>
  Mavenin käyttöönottoon on liittynyt kurssilla ongelmia. Tässä lyhyt ongelmanratkaisuopas.
</p>

<h3 class="material-heading">
    Linux ja Mac

</h3>

<p>
  Ongelma: Maven-binäärin suoritusoikeudet puuttuvat. Mavenin virhe on (esimerkiksi) muotoa.
</p>

<pre>
Cannot run program
  /Applications/tmcbeans.app/Contents/Resources/tmcbeans/java/maven/bin/mvn"
  (in directory "/Users/[nimi]/NetBeansProjects/hy-[kurssi]/[tehtava]"):
  error=13,
  Permission denied
</pre>

<p>
  Ratkaisu: lisää maven-binäärille suoritusoikeudet. Suorita terminaalissa (pääte) komento.
</p>

<pre>
chmod +x /Applications/tmcbeans.app/Contents/Resources/tmcbeans/java/maven/bin/mvn
</pre>

<p>
  Huomaa, että edellä polku on sama kuin virheviestin "Cannot run program"-polku.
</p>

<h3 class="material-heading">
    Windows

</h3>

<p>
  Ongelma: Ympäristömuuttuja <code>JAVA_HOME</code> ei ole asetettu. Käytännössä Maven yrittää etsiä Javaa, mutta ei löydä sitä.
</p>

<p>
  Ratkaisu: Lisää Windowsiin JAVA_HOME ympäristömuuttuja (esim.) osoitteessa <a href="https://confluence.atlassian.com/doc/setting-the-java_home-variable-in-windows-8895.html" target="_blank" norel>https://confluence.atlassian.com/doc/setting-the-java_home-variable-in-windows-8895.html</a> olevia ohjeita seuraamalla. Huomaa, että kansion tulee olla jdk, ei jre.
</p>


<h3 class="material-heading">
    Tietojenkäsittelytieteen laitoksen koneet

</h3>

<p>
  Ongelma: Riippuvuuksien lataaminen ei onnistu tai ne eivät toimi. Tässä syynä on joko loppunut levytila tai verkkoyhteysongelma. Levytilan tilanteen saa selvitettyä komennolla "quota".
</p>

<p>
  Ratkaisu:
</p>

<ol>
  <li>
    Poista vanhat ohjelmoinnin perusteiden (ja mahdollisesti muiden TMCtä käyttävien kurssien) tehtäväpohjat. Nämä löytyvät kotikansiosta kansion NetBeansProjects alta. Kannattanee harkita myös muiden turhien tiedostojen poistamista sekä esimerkiksi selaimen välimuistin tyhjentämistä ajoittain.
  </li>

  <li>
    Poista kotikansiossa olevan .m2-kansion sisältö. Tämä tehdään sillä Maven luo ladattavista riippuvuuksista (eli kirjastoista) vahingossa tyhjät tiedostot mikäli levytila on loppunut.
  </li>

  <li>
    (Jatkuva) Kun saat tehtäviä lähetettyä TMC:lle, klikkaa tehtäväpohjaa ja valitse "clean". Tämä poistaa tehtäväpohjasta käännetyt tiedostot.
  </li>
</ol>




<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Breakout</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    <a href="https://en.wikipedia.org/wiki/Breakout_(video_game)" target="_blank" rel="noopener">Breakout</a> on <a href="https://en.wikipedia.org/wiki/Atari,_Inc." target="_blank" rel="noopener">Atarin</a> vuonna 1976 julkaisema videopeli. Pelin ideana käyttää pelin alalaidassa olevaa mailaa pelissä liikkuvan pallon lyömiseen siten, että pallolla saadaan rikottua ylälaidassa olevia palasia.
  </p>

  <p>
    Termi "Breakout" tulee tilanteesta, missä pelaaja saa pallon ylälaidassa olevien palasten yläpuolelle, missä pallo tekee tuhoa useammalle palalle samaan aikaan.
  </p>

  <p>
    Tässä tehtävässä fiilistellään Breakout-pelin tekemistä.
  </p>

  <p>
    Tehtäväpohjaan on toteutettuna ensimmäisiä palasia Breakout peliin. Tehtävänäsi on täydentää pelin toimintaa. Alla lista täydennysehdotuksista:
  </p>

  <ol>
    <li>Tällä hetkellä pelin ylälaidassa on vain muutama vaivainen palikka. Muokkaa peliä siten, että ylälaidassa on useita erivärisiä palikoita. Hae inspiraatiota <a href="https://images.google.com" target="_blank" rel="noopener">Googlen kuvahausta</a> avainsanalla "Breakout".</li>
    <li>Pelin pelattavuus on tällä hetkellä melko heikko. Mailalla ei osuta palloon, vaikka kuinka yritettäisiin. Lisää peliin mahdollisuus osua mailalla palloon -- palloon osumisen pitäisi muuttaa pallon suuntaa. Osoitteesta <a href="http://www.edu4java.com/en/game/game6.html" target="_blank" rel="noopener">http://www.edu4java.com/en/game/game6.html</a> olevasta oppaasta saattaa olla hyötyä. Hifistelyä kaipaavat voivat lähteä liikenteeseen kysymyksestä <a href="http://gamedev.stackexchange.com/questions/10911/a-ball-hits-the-corner-where-will-it-deflect" target="_blank" rel="noopener">A ball hits the corner, where will it deflect?</a></li>
    <li>Kun pallon osuminen mailaan on hanskassa, lisää samanlainen osumistoiminnallisuus kaikkiin paloihin. Tässä kohtaa paloja ei vielä tarvitse poistaa.</li>
    <li>Kun pallo osuu palaan, pala pitäisi poistaa. Sehän on melkein jo peli!</li>
    <li>Mieti minkälaisia luokkia pelissä kannattaisi olla. Nyt piirtämiseen käytetty paikka sisältää varmaankin jo hyvin paljon koodia.. Siistimisen paikka!</li>
  </ol>

  <p>
    Tehtävässä ei ole automaattisia testejä ja se on yhden pisteen arvoinen. Voit palauttaa tehtävän jo kun saat ensimmäisen parannusehdotuksen tehtyä mutta peliä saa toki viilata enemmänkin.
  </p>



    </div>
  </div>
</div>



<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Kellosta olio</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Teimme aiemmin luokan <code>YlhaaltaRajoitettuLaskuri</code> ja rakennettiin laskurien avulla pääohjelmaan kello. Tehdään tässä tehtävässä kellostakin oma olio -- kello sisältää kolme viisaria, jotka jokainen esitetään ylhäältä rajoitetun laskurin avulla. Luokan kello runko näyttää seuraavalta:
  </p>

<pre class="sh_java code-highlight"><code>public class Kello {
private YlhaaltaRajoitettuLaskuri tunnit;
private YlhaaltaRajoitettuLaskuri minuutit;
private YlhaaltaRajoitettuLaskuri sekunnit;

public Kello(int tunnitAlussa, int minuutitAlussa, int sekunnitAlussa) {
// laskurit tunneille, minuuteille ja sekunneille;
// laskurien arvot tulee asettaa parametreina saatuun aikaan
}

public void etene() {
// kello etenee sekunnilla
}

public String toString() {
// palauttaa kellon merkkijonoesityksen
}
}
</code></pre>

  <p>
    Luokkaan YlhaaltaRajoitettuLaskuri on kopioitu eräs ratkaisu viime osan tehtävään. Toteuta luokan <code>Kello</code> konstruktori ja puuttuvat metodit kolmea ylhäältä rajoitettua laskuria hyödyntäen.
  </p>

  <p>
    Voit testata kelloasi seuraavalla pääohjelmalla:
  </p>

<pre class="sh_java code-highlight"><code>public class Main {
public static void main(String[] args) {
Kello kello = new Kello(23, 59, 50);

int i = 0;
while (i &lt; 20) {
System.out.println(kello);
kello.etene();
i++;
}
}
}
</code></pre>

  <p>
    Tulostuksen tulisi edetä seuraavasti:
  </p>

<pre class="sample-output">23:59:50
23:59:51
23:59:52
23:59:53
23:59:54
23:59:55
23:59:56
23:59:57
23:59:58
23:59:59
00:00:00
00:00:01
...
</pre>



    </div>
  </div>
</div>



<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Työntekijän eläkevakuutus</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Työntekijän eläkevakuutus (TyEL) on lakisääteinen ja pakollinen maksu, jolla rahoitetaan suurin osa nykyisistä ja tulevista työeläkkeistä. Työntekijän eläkevakuutuksen maksamisesta vastaa sekä työnantaja että työntekijä: <a href="http://www.etk.fi/uutinen/tyoelakemaksut-vuonna-2017/" target="_blank">Eläketurvakeskuksen mukaan</a> työnantajan maksama TyEL-maksu on vuonna 2017 noin 18% työntekijän palkasta, kun taas työntekijä maksaa palkastaan TyEL-maksua noin 6%.
  </p>

  <p>
    Työnantaja maksaa osuutensa bruttopalkan lisäksi, kun taas työntekijän maksama osuus otetaan bruttopalkasta (eli palkasta ennen ennakonpidätyksiä, vakuutusmaksuja ja muita vähennyksiä).
  </p>

  <p>
    Toteuta ohjelma, joka kertoo TyEL-kulut annetulle bruttopalkalle. Ohjelman tulee kertoa annetun bruttopalkan perusteella työnantajan maksut sekä palkasta tehtävät pidätykset. Käytä edellä annettuja arvioita (työnantajan osuus 18% ja työntekijän osuus 6%).
  </p>

<pre class="sample-output">Syötä bruttopalkka: <font color="red">800</font>
Työnantaja maksaa TyEL-maksuja: 144
Työntekijä maksaa työnantajalle vähintään: 944

Työntekijä maksaa TyEL-maksuja: 48
Työntekijän palkka TyEL-maksun jälkeen: 752

TyEL-kulut yhteensä: 192
</pre>


<pre class="sample-output">Syötä bruttopalkka: <font color="red">1000</font>
Työnantaja maksaa TyEL-maksuja: 180
Työntekijä maksaa työnantajalle vähintään: 1180

Työntekijä maksaa TyEL-maksuja: 60
Työntekijän palkka TyEL-maksun jälkeen: 940

TyEL-kulut yhteensä: 240
</pre>


    </div>
  </div>
</div>


<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Lukujen keskiarvo</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Tehtävänannossa tulee käyttäjän syöttämien lukujen summan laskeva ohjelma. Ohjelma kysyy lukuja kunnes käyttäjä syöttää nollan. Tämän jälkeen lukujen lukeminen loppuu, ja ohjelma tulostaa lukujen summan luvun.
  </p>

  <p>
    Muokkaa ohjelmaa siten, että ohjelma tulostaa syötettyjen lukujen summa lisäksi syötettyjen lukujen keskiarvon.
  </p>



    </div>
  </div>
</div>

<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Salapaikka ranskassa</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Kameralta kuvien kopioimiseen tarkoitetun ohjelmiston toteuttaja löysi ohjelmastaan virheen, jonka lopputulos näkyy tehtäväpohjassa olevan ohjelman näyttämässä kuvassa. Ohjelmiston toteuttaja kertoo seuraavaa.
  </p>
  
  <p>
    "Tämä virhe oli aika harmittava. Se muutti kaikki siniset ja vihreät väriarvot pelkäksi kohinaksi, joten niistä ei ole mitään iloa eikä niitä saa koskaan takaisin kuvaan. Lisäksi punaisen värin määrä jokaisessa pikselissä jakautui noin kymmenellä kopioinnin yhteydessä, joten kuvan punainen väri on aivan liian tumma."
  </p>

  <p>
    Selvitä kopiointiohjelmiston mitä kuvassa näkyy ja mistä kuva on otettu. Tietokoneella kuvatiedostoja käsitellään yleensä <a href="https://fi.wikipedia.org/wiki/RGB-v%C3%A4rimalli" target="_blank" norel>RGB-värimallin</a> kautta. Tässä tapauksessa jokaisen värin arvo on välillä 0-1, ja jokainen väriarvo esitetään desimaalilukuna.
  </p>
  



    </div>
  </div>
</div>



<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Fibonaccin lukujono</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Fibonaccin lukujonon ajatuksena on laskea yhteen kaksi edellistä lukua, ja näin saada seuraavan luvun arvo. Lukujonon ensimmäiset kaksi lukua ovat 0 ja 1. Seuraavan luvun saa laskettua aina kahden edellisen luvun summana.
  </p>

  <p>
    Toteuta ohjelma, joka ensin laskee Fibonaccin lukujonon ensimmäiset 40 lukua listalle. Ohjelma kysyy tämän jälkeen käyttäjältä halutun Fibonaccin luvun kohtaa. Kun käyttäjä syöttää luvun -- oleta, että luku on indeksi listalla -- ohjelma tulostaa halutun luvun.
  </p>

  <p>
    Ohjelman suoritus päättyy kun käyttäjä syöttää luvun -1.
  </p>

<pre class="sample-output">Monesko luku? <font color="red">0</font>
0
Monesko luku? <font color="red">1</font>
1
Monesko luku? <font color="red">7</font>
13
Monesko luku? <font color="red">22</font>
17711
Monesko luku? <font color="red">-1</font>

Kiitos!
</pre>


    </div>
  </div>
</div>



<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Pong</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Tässä tehtävässä täydennetään erästä tietokonepelien klassikkoa, <a href="https://en.wikipedia.org/wiki/Pong" target="_blank" norel>Pongia</a>. Tavoitteena pelissä on saada pallo lyötyä vastustajan mailasta ohi. Pisteen saa aina kun pallo osuu seinään. Tehtäväpohjaan on hahmoteltu Pong-peliä, joka näyttää seuraavalta:
  </p>

  <img src="../img/pong-screenshot-0073321c.png"/>

  <p>
    Pelin saa käynnistettyä valitsemalla luokan PongApplication ja suorittamalla sen. Vasenta mailaa voi ohjata napeilla w ja s, oikeaa mailaa nuolinäppäimillä.
  </p>
  
  <p>
    Pohjasta puuttuu kuitenkin merkittävä osa pelin toiminnallisuudesta. Tässä tehtävässä tavoitteenasi on tutustua olemassaolevaan ohjelmaan ja täydentää peliä sopivasti. Tässä muutamia täydennysehdotuksia:
  </p>

  <ol>
    <li>
      Pisteiden tulee muuttua kun pallo osuu seinään.
    </li>
    <li>
      Jos pallo osuu mailaan sen tulee kimmota mailasta.
    </li>
    <li>
      Mailan nopeuden pitäisi olla suurempi.
    </li>
    <li>
      Mailan ei pitäisi poistua alueelta.
    </li>
    <li>
      pallon nopeuden tulee kasvaa pelin edetessä.
    </li>
    <li>
      ...
    </li>
  </ol>

  <p>
    Tehtävässä ei ole testejä ja sen tekemisestä saa yhden pisteen. Saat itse käytännössä määritellä mitä tehtävän tekeminen tarkoittaa, eli voit vapaasti tehdä pelistä hyvinkin monimuotoisen, jota ehkäpä päädyt jopa demoamaan jollekin.
  </p>

  


    </div>
  </div>
</div>




<li>
  typonator-olio?
</li>
<li>
  emojohdanto?
</li>
<li>
  luokkakaaviot selkeämmiksi (ei käsin piirretyn näköisiä)
</li>
<li>
  selitystehtävä olioista? vertaispalaute selitystehtävästä?
</li>

-----


<h1 class="material-heading">
    Muutamia yleishyödyllisiä tekniikoita

</h1>


<p>
  Tutustutaan seuraavaksi muutamaan ohjelmoinnissa varsin näppärään tekniikaan sekä luokkaan.
</p>


<h2 class="material-heading">
    Säännölliset lausekkeet

</h2>

<p>
  Säännöllinen lauseke määrittelee joukon merkkijonoja tiiviissä muodossa. Säännöllisiä lausekkeita käytetään muunmuassa merkkijonojen oikeellisuuden tarkistamiseen. Merkkijonojen oikeellisuuden tarkastaminen tapahtuu luomalla säännöllinen lauseke, joka määrittelee merkkijonot, jotka ovat oikein.
</p>

<p>
  Tarkastellaan ongelmaa, jossa täytyy tarkistaa, onko käyttäjän antama opiskelijanumero oikeanmuotoinen. Opiskelijanumero alkaa merkkijonolla "01", jota seuraa 7 numeroa väliltä 0&ndash;9.
</p>

<p>
  Opiskelijanumeron oikeellisuuden voisi tarkistaa esimerkiksi käymällä opiskelijanumeroa esittävän merkkijonon läpi merkki merkiltä <code>charAt</code>-metodin avulla. Toinen tapa olisi tarkistaa että ensimmäinen merkki on "0", ja käyttää <code>Integer.parseInt</code> metodikutsua merkkijonon muuntamiseen numeroksi. Tämän jälkeen voisi tarkistaa että <code>Integer.parseInt</code>-metodin palauttama luku on pienempi kuin 20000000.
</p>

<p>
  Oikeellisuuden tarkistus säännöllisten lausekkeiden avulla tapahtuu ensin sopivan säännöllisen lausekkeen määrittelyn. Tämän jälkeen käytetään <code>String</code>-luokan metodia <code>matches</code>, joka tarkistaa vastaako merkkijono parametrina annettua säännöllistä lauseketta. Opiskelijanumeron tapauksessa sopiva säännöllinen lauseke on <code>"01[0-9]{7}"</code>, ja käyttäjän syöttämän opiskelijanumeron tarkistaminen käy seuraavasti:
</p>

<pre class="sh_java code-highlight"><code>System.out.print("Anna opiskelijanumero: ");
String numero = lukija.nextLine();

if (numero.matches("01[0-9]{7}")) {
System.out.println("Muoto on oikea.");
} else {
System.out.println("Muoto ei ole oikea.");
}
</code></pre>

<p>
  Käydään seuraavaksi läpi eniten käytettyjä säännöllisten lausekkeiden merkintöjä.
</p>


<h3 class="material-heading">
    Vaihtoehtoisuus (pystyviiva)

</h3>

<p>
  Pystyviiva tarkoittaa, että säännöllisen lausekkeen osat ovat vaihtoehtoisia. Esimerkiksi lauseke <code>00|111|0000</code> määrittelee merkkijonot <code>00</code>, <code>111</code> ja <code>0000</code>. Metodi <code>matches</code> palauttaa arvon <code>true</code> jos merkkijono vastaa jotain määritellyistä vaihtoehdoista.
</p>

<pre class="sh_java code-highlight"><code>String merkkijono = "00";

if (merkkijono.matches("00|111|0000")) {
System.out.println("Merkkijonosta löytyi joku kolmesta vaihtoehdosta");
} else {
System.out.println("Merkkijonosta ei löytynyt yhtäkään vaihtoehdoista");
}
</code></pre>


<pre class="sample-output">Merkkijonosta löytyi joku kolmesta vaihtoehdosta
</pre>

<p>
  Säännöllinen lauseke <code>00|111|0000</code> vaatii että merkkijono on täsmälleen määritellyn muotoinen: se ei määrittele <em>"contains"</em>-toiminnallisuutta.
</p>

<pre class="sh_java code-highlight"><code>String merkkijono = "1111";

if (merkkijono.matches("00|111|0000")) {
System.out.println("Merkkijonosta löytyi joku kolmesta vaihtoehdosta");
} else {
System.out.println("Merkkijonosta ei löytynyt yhtäkään vaihtoehdoista");
}
</code></pre>

<pre class="sample-output">Merkkijonosta ei löytynyt yhtäkään vaihtoehdoista
</pre>


<h3 class="material-heading">
    Merkkijonon osaan rajattu vaikutus (sulut)

</h3>

<p>
  Sulkujen avulla voi määrittää, mihin säännöllisen lausekkeen osaan sulkujen sisällä olevat merkinnät vaikuttavat. Jos haluamme sallia merkkijonot <code>00000</code> ja <code>00001</code>, voimme määritellä ne pystyviivan avulla muodossa <code>00000|00001</code>. Sulkujen avulla voimme rajoittaa vaihtoehtoisuuden vain osaan merkkijonoa. Lauseke <code>0000(0|1)</code> määrittelee merkkijonot <code>00000</code> ja <code>00001</code>.
</p>

<p>
  Vastaavasti säännöllinen lauseke <code>auto(|n|a)</code> määrittelee sanan auto yksikön nominatiivin (auto), genetiivin (auton), partitiivin (autoa) ja akkusatiivin (auto tai auton).
</p>

<pre class="sh_java code-highlight"><code>System.out.print("Kirjoita joku sanan auto yksikön taivutusmuoto: ");
String sana = lukija.nextLine();

if (sana.matches("auto(|n|a|ssa|sta|on|lla|lta|lle|na|ksi|tta)")) {
System.out.println("Oikein meni! RRrakastan tätä kieltä!");
} else {
System.out.println("Taivutusmuoto ei ole oikea.");
}
</code></pre>


<h3 class="material-heading">
    Toistomerkinnät

</h3>

<p>
  Usein halutaan, että merkkijonossa toistuu jokin tietty alimerkkijono. Säännöllisissä lausekkeissa on käytössä seuraavat toistomerkinnät:
</p>

<ul>
  <li>Merkintä <strong><code>*</code></strong> toisto 0... kertaa, esim<br/>
<pre class="sh_java code-highlight"><code>String merkkijono = "trolololololo";

if (merkkijono.matches("trolo(lo)*")) {
System.out.println("Muoto on oikea.");
} else {
System.out.println("Muoto ei ole oikea.");
}
</code></pre>

<pre class="sample-output">Muoto on oikea.
</pre>
  </li>

  <li>Merkintä <strong><code>+</code></strong> toisto 1... kertaa, esim<br/>
<pre class="sh_java code-highlight"><code>String merkkijono = "trolololololo";

if (merkkijono.matches("tro(lo)+")) {
System.out.println("Muoto on oikea.");
} else {
System.out.println("Muoto ei ole oikea.");
}
</code></pre>

<pre class="sample-output">Muoto on oikea.
</pre>

<pre class="sh_java code-highlight"><code>String merkkijono = "nänänänänänänänä Bätmään!";

if (merkkijono.matches("(nä)+ Bätmään!")) {
System.out.println("Muoto on oikea.");
} else {
System.out.println("Muoto ei ole oikea.");
}
</code></pre>

<pre class="sample-output">Muoto on oikea.
</pre>
  </li>

  <li>Merkintä <strong><code>?</code></strong> toisto 0 tai 1 kertaa, esim<br/>

<pre class="sh_java code-highlight"><code>String merkkijono = "You have to accidentally the whole meme";

if (merkkijono.matches("You have to accidentally (delete )?the whole meme")) {
System.out.println("Muoto on oikea.");
} else {
System.out.println("Muoto ei ole oikea.");
}
</code></pre>

<pre class="sample-output">Muoto on oikea.
</pre>
  </li>

  <li>Merkintä <strong><code>{a}</code></strong> toisto <code>a</code> kertaa, esim<br/>
<pre class="sh_java code-highlight"><code>String merkkijono = "1010";

if (merkkijono.matches("(10){2}")) {
System.out.println("Muoto on oikea.");
} else {
System.out.println("Muoto ei ole oikea.");
}
</code></pre>

<pre class="sample-output">Muoto on oikea.
</pre>
  </li>

  <li>Merkintä <strong><code>{a,b}</code></strong> toisto <code>a</code> ... <code>b</code> kertaa, esim<br/>
<pre class="sh_java code-highlight"><code>String merkkijono = "1";

if (merkkijono.matches("1{2,4}")) {
System.out.println("Muoto on oikea.");
} else {
System.out.println("Muoto ei ole oikea.");
}
</code></pre>

<pre class="sample-output">Muoto ei ole oikea.
</pre>
  </li>

  <li>Merkintä <strong><code>{a,}</code></strong> toisto <code>a</code> ... kertaa, esim<br/>
<pre class="sh_java code-highlight"><code>String merkkijono = "11111";

if (merkkijono.matches("1{2,}")) {
System.out.println("Muoto on oikea.");
} else {
System.out.println("Muoto ei ole oikea.");
}
</code></pre>

<pre class="sample-output">Muoto on oikea.
</pre>
  </li>
</ul>

<p>
  Samassa säännöllisessä lausekkeessa voi käyttää myös useampia toistomerkintöjä. Esimerkiksi säännöllinen lauseke <code>5{3}(1|0)*5{3}</code> määrittelee merkkijonot, jotka alkavat ja loppuvat kolmella vitosella. Välissä saa tulla rajaton määrä ykkösiä ja nollia.
</p>


<h3 class="material-heading">
    Merkkiryhmät (hakasulut)

</h3>

<p>
  Merkkiryhmän avulla voi määritellä lyhyesti joukon merkkejä. Merkit kirjoitetaan hakasulkujen sisään, ja merkkivälin voi määrittää viivan avulla. Esimerkiksi merkintä <code>[145]</code> tarkoittaa samaa kuin <code>(1|4|5)</code> ja merkintä <code>[2-36-9]</code> tarkoittaa samaa kuin <code>(2|3|6|7|8|9)</code>. Vastaavasti merkintä <code>[a-c]*</code> määrittelee säännöllisen lausekkeen, joka vaatii että merkkijono sisältää vain merkkejä <code>a</code>, <code>b</code> ja <code>c</code>.
</p>


<div class="quiznator-plugin" data-quiz-id="5a02e242fb43ca000414c18f"></div>



<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Säännölliset lausekkeet (3 osaa)</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Harjoitellaan hieman säännöllisten lausekkeiden käyttöä. Tehtävissä haetut metodit tehdään luokkaan <code>Tarkistin</code>.
  </p>


  <h2>Viikonpäivä</h2>

  <p>
    Tee säännöllisen lausekkeen avulla metodi <code>public boolean onViikonpaiva(String merkkijono)</code>, joka palauttaa <code>true</code> jos sen parametrina saama merkkijono on viikonpäivän lyhenne (ma, ti, ke, to, pe, la tai su).
  </p>

  <p>
    Esimerkkitulostuksia metodia käyttävästä ohjelmasta:
  </p>

<pre class="sample-output">Anna merkkijono: <font color="red">ti</font>
Muoto on oikea.
</pre>

<pre class="sample-output">Anna merkkijono: <font color="red">abc</font>
Muoto ei ole oikea.
</pre>


  <h2>Vokaalitarkistus</h2>

  <p>
    Tee metodi <code>public boolean kaikkiVokaaleja(String merkkijono)</code> joka tarkistaa säännöllisen lausekkeen avulla ovatko parametrina olevan merkkijonon kaikki merkit vokaaleja.
  </p>

  <p>
    Esimerkkitulostuksia metodia käyttävästä ohjelmasta:
  </p>

<pre class="sample-output">Anna merkkijono: <font color="red">aie</font>
Muoto on oikea.
</pre>

<pre class="sample-output">Anna merkkijono: <font color="red">ane</font>
Muoto ei ole oikea.
</pre>


  <h2>Kellonaika</h2>

  <p>
    Säännölliset lausekkeet sopivat tietynlaisiin tilanteisiin. Joissain tapaukseesa lausekkeista tulee liian monimutkaisia, ja merkkijonon "sopivuus" kannattaa tarkastaa muulla tyylillä tai voi olla tarkoituksenmukaista käyttää säännöllisiä lausekkeita vain osaan tarkastuksesta.
  </p>

  <p>
    Tee  metodi <code>public boolean kellonaika(String merkkijono)</code>  ohjelma, joka tarkistaa säännöllisen lausekkeen avulla onko parametrina oleva merkkijono muotoa <code>tt:mm:ss</code> oleva kellonaika (tunnit, minuutit ja sekunnit kaksinumeroisina).
  </p>

  <p>
    Esimerkkitulostuksia metodia käyttävästä ohjelmasta:
  </p>

<pre class="sample-output">Anna merkkijono: <font color="red">17:23:05</font>
Muoto on oikea.
</pre>

<pre class="sample-output">Anna merkkijono: <font color="red">abc</font>
Muoto ei ole oikea.
</pre>

<pre class="sample-output">Anna merkkijono: <font color="red">33:33:33</font>
Muoto ei ole oikea.
</pre>



    </div>
  </div>
</div>

<p>
  Nykyään lähes kaikista ohjelmointikielistä löytyy tuki säännöllisille lausekkeille. Säännöllisten lausekkeiden teoriaa tarkastellaan muunmuassa kurssilla <em>Laskennan mallit</em>. Lisää säännöllisistä lausekkeista löydät esim. googlaamalla hakusanalla <em>regular expressions java</em> -- kannattaa myös lukea Codinghorror-blogin lyhyt artikkeli <a href="https://blog.codinghorror.com/regex-use-vs-regex-abuse/" target="_blank" rel="noopener">Regex use vs. Regex abuse</a>.
</p>


<h2 class="material-heading">
    Lueteltu tyyppi eli Enum

</h2>

<p>
  Jos tiedämme muuttujien mahdolliset arvot ennalta, voimme käyttää niiden esittämiseen <code>enum</code>-tyyppistä luokkaa eli <em>lueteltua tyyppiä</em>. Luetellut tyypit ovat oma luokkatyyppinsä rajapinnan ja normaalin luokan lisäksi. Lueteltu tyyppi määritellään avainsanalla <code>enum</code>. Esimerkiksi seuraava <code>Maa</code>-enumluokka määrittelee neljä vakioarvoa: <code>RUUTU</code>, <code>PATA</code>, <code>RISTI</code> ja <code>HERTTA</code>.
</p>

<pre class="sh_java code-highlight"><code>public enum Maa {
RUUTU, PATA, RISTI, HERTTA
}
</code></pre>

<p>
  Yksinkertaisimmassa muodossaan <code>enum</code> luettelee pilkulla erotettuina määrittelemänsä vakioarvot. Lueteltujen tyyppien arvot eli vakiot on yleensä tapana kirjoittaa kokonaan isoin kirjaimin.
</p>

<p>
  Enum luodaan (yleensä) omaan tiedostoon, samaan tapaan kuin luokka tai rajapinta. NetBeansissa Enumin saa luotua valitsemalla projektin kohdalla <em>new/other/java/java enum</em>.
</p>

<p>
  Seuraavassa luokka <code>Kortti</code> jossa maa esitetään enumin avulla:
</p>

<pre class="sh_java code-highlight"><code>public class Kortti {

private int arvo;
private Maa maa;

public Kortti(int arvo, Maa maa) {
this.arvo = arvo;
this.maa = maa;
}

@Override
public String toString() {
return maa + " " + arvo;
}

public Maa getMaa() {
return maa;
}

public int getArvo() {
return arvo;
}
}
</code></pre>

<p>
  Korttia käytetään seuraavasti:
</p>

<pre class="sh_java code-highlight"><code>Kortti eka = new Kortti(10, Maa.HERTTA);

System.out.println(eka);

if (eka.getMaa() == Maa.PATA) {
System.out.println("on pata");
} else {
System.out.println("ei ole pata");
}
</code></pre>

<p>Tulostuu:</p>

<pre class="sample-output">HERTTA 10
ei ole pata
</pre>

<p>
  Huomaamme, että enumin tunnukset tulostuvat mukavasti! Koska kortin maat ovat nyt tyyppiä <code>Maa</code> ei ylemmän esimerkin "järjenvastaiset" kummallisuudet, esim. "maan korottaminen toiseen potenssiin" onnistu. Oraclella on <code>enum</code>-tyyppiin liittyvä sivusto osoitteessa <a href="http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html" target="_blank" rel="noopener">http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html</a>.
</p>



<div class="hint">
  <div class="hint__header">
    <i class="fa fa-info-circle hint__icon"></i>Enumien vertailu
  </div>

  <div class="hint__body">
    
  <p>
    Ylläolevassa esimerkissä kahta enumia verrattiin yhtäsuuruusmerkkien avulla. Miksi tämä on ok?
  </p>

  <p>
    Jokainen lueteltu arvo saa oman uniikin numerotunnuksen, ja niiden vertailu keskenään yhtäsuuruusmerkillä on ok. Kuten muutkin Javan luokat, myös luetellut arvot perivät Object-luokan ja sen equals-metodin. Luetelluilla luokilla myös equals-metodi vertailee tätä numerotunnusta.
  </p>

  <p>
    Luetellun arvon numeraalisen tunnuksen saa selville metodille <code>ordinal()</code>. Metodi palauttaa käytännössä järjestysnumeron -- jos lueteltu arvo on esitelty ensimmäisenä, on sen järjestysnumero 0. Jos toisena, järjestysnumero on 1, jne.
  </p>

  
<pre class="sh_java code-highlight"><code>public enum Maa {
RUUTU, PATA, RISTI, HERTTA
}
</code></pre>

<pre class="sh_java code-highlight"><code>System.out.println(Maa.RUUTU.ordinal());
System.out.println(Maa.HERTTA.ordinal());
</code></pre>

<pre class="sample-output">0
3
</pre>
  

  </div>
</div>


<h3 class="material-heading">
    Lueteltujen tyyppien oliomuuttujat

</h3>

<p>
  Luetellut tyypit voivat sisältää oliomuuttujia. Oliomuuttujien arvot tulee asettaa luetellun tyypin määrittelevän luokan sisäisessä eli näkyvyysmääreen <code>private</code> omaavassa konstruktorissa. Enum-tyyppisillä luokilla ei saa olla <code>public</code>-konstruktoria.
</p>

<p>
  Seuraavassa lueteltu tyyppi <code>Vari</code>, joka sisältää vakioarvot PUNAINEN, VIHREA ja SININEN. Vakioille on määritelty <a href="https://www.w3schools.com/colors/colors_picker.asp" target="_blank" rel="noopener">värikoodin</a> kertova oliomuuttuja:
</p>

<pre class="sh_java code-highlight"><code>public enum Vari {
// konstruktorin parametrit määritellään vakioarvoja lueteltaessa
PUNAINEN("#FF0000"),
VIHREA("#00FF00"),
SININEN("#0000FF");

private String koodi;        // oliomuuttuja

private Vari(String koodi) { // konstruktori
this.koodi = koodi;
}

public String getKoodi() {
return this.koodi;
}
}
</code></pre>

<p>
  Lueteltua tyyppiä <code>Vari</code> voidaan käyttää esimerkiksi seuraavasti:
</p>

<pre class="sh_java code-highlight"><code>System.out.println(Vari.VIHREA.getKoodi());
</code></pre>

<pre class="sample-output">#00FF00
</pre>


<h2 class="material-heading">
    Iteraattori

</h2>

<p>
  Tarkastellaan seuraavaa luokkaa <code>Kasi</code>, joka mallintaa tietyssä korttipelissä pelaajan kädessä olevien korttien joukkoa:
</p>

<pre class="sh_java code-highlight"><code>public class Kasi {
private List&lt;Kortti&gt; kortit;

public Kasi() {
this.kortit = new ArrayList&lt;&gt;();
}

public void lisaa(Kortti kortti) {
this.kortit.add(kortti);
}

public void tulosta() {
this.kortit.stream().forEach(kortti -&gt; {
System.out.println(kortti);
});
}
}
</code></pre>

<p>
  Luokan metodi <code>tulosta</code> tulostaa jokaisen kädessä olevan kortin.
</p>

<p>
  ArrayList ja muut <em>Collection</em>-rajapinnan toteuttavat "oliosäiliöt" toteuttavat rajapinnan <em>Iterable</em>, ja ne voidaan käydä läpi myös käyttäen <em>iteraattoria</em>, eli olioa, joka on varta vasten tarkoitettu tietyn oliokokoelman läpikäyntiin. Seuraavassa on iteraattoria käyttävä versio korttien tulostamisesta:
</p>

<pre class="sh_java code-highlight"><code>public void tulosta() {
Iterator&lt;Kortti&gt; iteraattori = kortit.iterator();

while (iteraattori.hasNext()) {
System.out.println(iteraattori.next());
}
}
</code></pre>

<p>
  Iteraattori pyydetään kortteja sisältävältä listalta <code>kortit</code>. Iteraattori on ikäänkuin "sormi", joka osoittaa aina tiettyä listan sisällä olevaa olioa, ensin ensimmäistä ja sitten seuraavaa jne... kunnes "sormen" avulla on käyty jokainen olio läpi.
</p>

<p>
  Iteraattori tarjoaa muutaman metodin. Metodilla <code>hasNext()</code> kysytään onko läpikäytäviä olioita vielä jäljellä. Jos on, voidaan iteraattorilta pyytää seuraavana vuorossa oleva olio metodilla <code>next()</code>. Metodi siis palauttaa seuraavana läpikäyntivuorossa olevan olion ja laittaa iteraattorin eli "sormen" osoittamaan seuraavana vuorossa olevaa läpikäytävää olioa.
</p>

<p>
  Iteraattorin next-metodin palauttama olioviite voidaan ottaa toki talteen myös muuttujaan, eli metodi <code>tulosta</code> voitaisiin muotoilla myös seuraavasti.
</p>

<pre class="sh_java code-highlight"><code>public void tulosta(){
Iterator&lt;Kortti&gt; iteraattori = kortit.iterator();

while (iteraattori.hasNext()) {
Kortti seuraavanaVuorossa = iteraattori.next();
System.out.println(seuraavanaVuorossa);
}
}
</code></pre>


<p>
  Tarkastellaan seuraavaksi yhtä iteraattorin käyttökohdetta. Motivoidaan käyttökohde ensin ongelmallisella lähestymistavalla. Yritämme tehdä virran avulla metodia, joka poistaa käsiteltävästä virrasta ne kortit, joiden arvo on annettua arvoa pienempi.
</p>

<pre class="sh_java code-highlight"><code>public class Kasi {
// ...

public void poistaHuonommat(int arvo) {
this.kortit.stream().forEach(kortti -&gt; {
if (kortti.getArvo() &lt; arvo) {
kortit.remove(kortti);
}
});
}
}
</code></pre>

<p>
  Metodin suoritus aiheuttaa ongelman.
</p>

<pre class="sample-output">Exception in thread "main" java.util.ConcurrentModificationException
at ...
Java Result: 1
</pre>

<p>
  Virheen syynä on se, että listan läpikäynti forEach-metodilla olettaa, ettei listaa muokata läpikäynnin yhteydessä. Listan muokkaaminen (eli tässä tapauksessa alkion poistaminen) aiheuttaa virheen -- voimme ajatella, että komento forEach menee tästä "sekaisin".
</p>

<p>
  Jos listalta halutaan poistaa osa olioista läpikäynnin aikana osa, tulee tämä tehdä iteraattoria käyttäen. Iteraattori-olion metodia <code>remove</code> kutsuttaessa listalta poistetaan siististi se alkio jonka iteraattori palautti edellisellä metodin <code>next</code> kutsulla. Toimiva versio metodista seuraavassa:
</p>

<pre class="sh_java code-highlight"><code>public class Kasi {
// ...

public void poistaHuonommat(int arvo) {
Iterator&lt;Kortti&gt; iteraattori = kortit.iterator();

while (iteraattori.hasNext()) {
if (iteraattori.next().getArvo() &lt; arvo) {
// poistetaan listalta olio jonka edellinen next-metodin kutsu palautti
iteraattori.remove();
}
}
}
}
</code></pre>


<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Enum ja Iteraattori (4 osaa)</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Tehdään ohjelma pienen yrityksen henkilöstön hallintaan.
  </p>

  <h2>Koulutus</h2>

  <p>
    Tee pakkaukseen <code>henkilosto</code> lueteltu tyyppi eli enum <code>Koulutus</code> jolla on tunnukset <code>FT</code> (tohtori), <code>FM</code> (maisteri), <code>LuK</code> (kandidaatti), <code>FilYO</code> (ylioppilas).
  </p>

  <h2>Henkilo</h2>

  <p>
    Tee pakkaukseen <code>henkilosto</code> luokka Luokka <code>Henkilo</code>. Henkilölle annetaan konstruktorin parametrina annettava nimi ja koulutus. Henkilöllä on myös koulutuksen kertova metodi <code>public Koulutus getKoulutus()</code> sekä alla olevan esimerkin mukaista jälkeä tekevä <code>toString</code>-metodi.
  </p>

<pre class="sh_java code-highlight"><code>Henkilo vilma = new Henkilo("Vilma", Koulutus.FT);
System.out.println(vilma);
</code></pre>

<pre class="sample-output">Vilma, FT
</pre>


  <h2>Tyontekijat</h2>

  <p>
    Tee pakkaukseen <code>henkilosto</code> luokka Luokka <code>Tyontekijat</code>. Työntekijät-olio sisältää listan Henkilo-olioita. Luokalla on parametriton konstruktori ja seuraavat metodit:
  </p>

  <ul>
    <li><code>public void lisaa(Henkilo lisattava)</code> lisää parametrina olevan henkilön työntekijäksi</li>
    <li><code>public void lisaa(List&lt;Henkilo&gt; lisattavat)</code> lisää parametrina olevan listan henkilöitä työntekijöiksi</li>
    <li><code>public void tulosta()</code> tulostaa kaikki työntekijät</li>
    <li><code>public void tulosta(Koulutus koulutus)</code> tulostaa työntekijät joiden koulutus on sama kuin parametrissa määritelty koulutus</li>
  </ul>

  <p>
    <strong>HUOM:</strong> Luokan <code>Tyontekijat</code> <code>tulosta</code>-metodit on toteutettava iteraattoria käyttäen!
  </p>

  
  <h2>Irtisanominen</h2>

  <p>
    Tee luokalle  <code>Tyontekijat</code> metodi <code>public void irtisano(Koulutus koulutus)</code> joka poistaa Työntekijöiden joukosta kaikki henkilöt joiden koulutus on sama kuin metodin parametrina annettu.
  </p>

  <p>
    <strong>HUOM:</strong> toteuta metodi iteraattoria käyttäen!
  </p>

  <p>
    Seuraavassa esimerkki luokan käytöstä:
  </p>

<pre class="sh_java code-highlight"><code>Tyontekijat yliopisto = new Tyontekijat();
yliopisto.lisaa(new Henkilo("Petrus", Koulutus.FT));
yliopisto.lisaa(new Henkilo("Arto", Koulutus.FilYO));
yliopisto.lisaa(new Henkilo("Elina", Koulutus.FT));

yliopisto.tulosta();

yliopisto.irtisano(Koulutus.FilYO);

System.out.println("==");

yliopisto.tulosta();
</code></pre>

  <p>
    Tulostuu:
  </p>

<pre class="sample-output">Petrus, FT
Arto, FilYO
Elina, FT
==
Petrus, FT
Elina, FT
</pre>



    </div>
  </div>
</div>

<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Kortit ojennukseen (6 osaa)</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Tehtäväpohjan mukana on luokka, jonka oliot kuvaavat pelikortteja. Kortilla on arvo ja maa. Kortin arvo on esitetään numerona <em>2, 3, ..., 14</em> ja maa <em>Risti, Ruutu, Hertta</em> tai <em>Pata</em>. Ässä on siis arvo 14. Arvo esitetään kokonaislukuna ja maa enum-tyyppisenä oliona. Kortilla on myös metodi toString, jota käyttäen kortin arvo ja maa tulostuvat "ihmisystävällisesti".
  </p>

  <p>
    Korttien luominen tapahtuu seuraavasti. 
  </p>

<pre class="sh_java code-highlight"><code>Kortti eka = new Kortti(2, Maa.RUUTU);
Kortti toka = new Kortti(14, Maa.PATA);
Kortti kolmas = new Kortti(12, Maa.HERTTA);

System.out.println(eka);
System.out.println(toka);
System.out.println(kolmas);
</code></pre>

  <p>
    Tulostuu:
  </p>

<pre class="sample-output">RUUTU 2
PATA A
HERTTA Q
</pre>

  
  <h2>Kortti-luokasta Comparable</h2>

  <p>
    Tee Kortti-luokasta Comparable. Toteuta <code>compareTo</code>-metodi niin, että korttien järjestys on arvon mukaan nouseva. Jos verrattavien Korttien arvot ovat samat, verrataan niitä maan perusteella nousevassa järjestyksessä: <em>risti ensin, ruutu toiseksi, hertta kolmanneksi, pata viimeiseksi.</em>
  </p>

  <p>
    Maiden järjestämisessä apua löytynee <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Enum.html#ordinal--"  target="_blank" norel>Enum-luokan ordinal-metodista</a>.
  </p>

  <p>
    Järjestyksessä pienin kortti siis olisi risti kakkonen ja suurin pataässä.
  </p>

  
  <h2>Käsi</h2>

  <p>
    Tee seuraavaksi luokka <code>Kasi</code> joka edustaa pelaajan kädessään pitämää korttien joukkoa. Tee kädelle seuraavat metodit:
  </p>

  <ul>
    <li><code>public void lisaa(Kortti kortti)</code> lisää käteen kortin</li>
    <li><code>public void tulosta()</code> tulostaa kädessä olevat kortit alla olevan esimerkin tyylillä</li>
  </ul>

<pre class="sh_java code-highlight"><code>Kasi kasi = new Kasi();

kasi.lisaa(new Kortti(2, Maa.RUUTU));
kasi.lisaa(new Kortti(14, Maa.PATA));
kasi.lisaa(new Kortti(12, Maa.HERTTA));
kasi.lisaa(new Kortti(2, Maa.PATA));

kasi.tulosta();
</code></pre>

  <p>
    Tulostuu:
  </p>

<pre class="sample-output">RUUTU 2
PATA A
HERTTA Q
PATA 2
</pre>

  <p>
    Käytä ArrayListiä korttien tallentamiseen.
  </p>


  <h2>Käden järjestäminen</h2>

  <p>
    Tee kädelle metodi <code>public void jarjesta()</code> jota kutsumalla käden sisällä olevat kortit menevät suuruusjärjestykseen. Järjestämisen jälkeen kortit tulostuvat järjestyksessä:
  </p>

<pre class="sh_java code-highlight"><code>Kasi kasi = new Kasi();

kasi.lisaa(new Kortti(2, Maa.RUUTU));
kasi.lisaa(new Kortti(14, Maa.PATA));
kasi.lisaa(new Kortti(12, Maa.HERTTA));
kasi.lisaa(new Kortti(2, Maa.PATA));

kasi.jarjesta();

kasi.tulosta();
</code></pre>

  <p>
    Tulostuu:
  </p>

<pre class="sample-output">RUUTU 2
PATA 2
HERTTA Q
PATA A
</pre>

  
  <h2>Käsien vertailu</h2>

  <p>
    Eräässä korttipelissä kahdesta korttikädestä arvokkaampi on se, jonka sisältämien korttien arvon summa on suurempi. Tee luokasta <code>Kasi</code> vertailtava tämän kriteerin mukaan, eli laita luokka toteuttamaan rajapinta <code>Comparable&lt;Kasi&gt;</code>.
  </p>

  <p>
    Esimerkkiohjelma, jossa vertaillaan käsiä:
  </p>

<pre class="sh_java code-highlight"><code>Kasi kasi1 = new Kasi();

kasi1.lisaa(new Kortti(2, Maa.RUUTU));
kasi1.lisaa(new Kortti(14, Maa.PATA));
kasi1.lisaa(new Kortti(12, Maa.HERTTA));
kasi1.lisaa(new Kortti(2, Maa.PATA));

Kasi kasi2 = new Kasi();

kasi2.lisaa(new Kortti(11, Maa.RUUTU));
kasi2.lisaa(new Kortti(11, Maa.PATA));
kasi2.lisaa(new Kortti(11, Maa.HERTTA));

int vertailu = kasi1.compareTo(kasi2);

if (vertailu &lt; 0) {
System.out.println("arvokkaampi käsi sisältää kortit");
kasi2.tulosta();
} else if (vertailu &gt; 0){
System.out.println("arvokkaampi käsi sisältää kortit");
kasi1.tulosta();
} else {
System.out.println("kädet yhtä arvokkaat");
}
</code></pre>

  <p>Tulostuu</p>

<pre class="sample-output">arvokkaampi käsi sisältää kortit
RUUTU J
PATA J
HERTTA J
</pre>

  
  <h2>Korttien järjestäminen eri kriteerein</h2>

  <p>
    Entä jos haluaisimme välillä järjestää kortit hieman eri tavalla, esim. kaikki saman maan kortit peräkkäin? Luokalla voi olla vain yksi compareTo-metodi, joten joudumme muunlaisia järjestyksiä saadaksemme turvautumaan muihin keinoihin.
  </p>

  <p>
    Vaihtoehtoiset järjestämistavat toteutetaan erillisten vertailun suorittavien luokkien avulla. Korttien vaihtoehtoisten järjestyksen määräävän luokkien tulee toteuttaa <code>Comparator&lt;Kortti&gt;</code>-rajapinta. Järjestyksen määräävän luokan olio vertailee kahta parametrina saamaansa korttia. Metodeja on ainoastaan yksi compare(Kortti k1, Kortti k2), jonka tulee palauttaa negatiivinen arvo, jos kortti k1 on järjestyksessä ennen korttia k2, positiivinen arvo jos k2 on järjestyksessä ennen k1:stä ja 0 muuten.
  </p>

  <p>
    Periaatteena on luoda jokaista järjestämistapaa varten oma vertailuluokka, esim. saman maan kortit vierekkäin vievän järjestyksen määrittelevä luokka:
  </p>

<pre class="sh_java code-highlight"><code>import java.util.Comparator;

public class SamatMaatVierekkain implements Comparator&lt;Kortti&gt; {
public int compare(Kortti k1, Kortti k2) {
return k1.getMaa().ordinal() - k2.getMaa().ordinal();
}
}
</code></pre>

  <p>
    Maittainen järjestys on sama kuin kortin metodin <code>compareTo</code> maille määrittelemä järjestys eli <em>ristit ensin, ruudut toiseksi, hertat kolmanneksi, padat viimeiseksi.</em>
  </p>

  <p>
    Järjestäminen tapahtuu edelleen luokan Collections metodin sort avulla. Metodi saa nyt toiseksi parametrikseen järjestyksen määräävän luokan olion:
  </p>
  
<pre class="sh_java code-highlight"><code>ArrayList&lt;Kortti&gt; kortit = new ArrayList&lt;&gt;();

kortit.add(new Kortti(3, Maa.PATA));
kortit.add(new Kortti(2, Maa.RUUTU));
kortit.add(new Kortti(14, Maa.PATA));
kortit.add(new Kortti(12, Maa.HERTTA));
kortit.add(new Kortti(2, Maa.PATA));

SamatMaatVierekkain samatMaatVierekkainJarjestaja = new SamatMaatVierekkain();
Collections.sort(kortit, samatMaatVierekkainJarjestaja);

kortit.stream().forEach(k -&gt; System.out.println(k));
</code></pre>

  <p>
    Tulostuu:
  </p>

<pre class="sample-output">RUUTU 2
HERTTA Q
PATA 3
PATA A
PATA 2
</pre>

  <p>
    Järjestyksen määrittelevä olio voidaan myös luoda suoraan sort-kutsun yhteydessä:
  </p>
  
<pre class="sh_java code-highlight"><code>Collections.sort(kortit, new SamatMaatVierekkain());
</code></pre>


  <p>
    Tarkempia ohjeita vertailuluokkien tekemiseen <a href="http://leepoint.net/data/collections/comparators.html">täällä</a>
  </p>

  <p>
    Tee nyt luokka Comparator-rajapinnan toteuttava luokka <code>SamatMaatVierekkainArvojarjestykseen</code> jonka avulla saat kortit muuten samanlaiseen järjestykseen kuin edellisessä esimerkissä paitsi, että saman maan kortit järjestyvät arvon mukaisesti.
  </p>


  <h2>Käden järjestäminen maittain</h2>

  <p>
    Lisää luokalle <code>Kasi</code> metodi <code>public void jarjestaMaittain()</code> jota kutsumalla käden sisällä olevat kortit menevät edellisen tehtävän vertailijan määrittelemään järjestykseen. Järjestämisen jälkeen kortit tulostuvat järjestyksessä:
  </p>

<pre class="sh_java code-highlight"><code>Kasi kasi = new Kasi();

kasi.lisaa(new Kortti(12, Maa.HERTTA));
kasi.lisaa(new Kortti(4, Maa.PATA));
kasi.lisaa(new Kortti(2, Maa.RUUTU));
kasi.lisaa(new Kortti(14, Maa.PATA));
kasi.lisaa(new Kortti(7, Maa.HERTTA));
kasi.lisaa(new Kortti(2, Maa.PATA));

kasi.jarjestaMaittain();

kasi.tulosta();
</code></pre>
  
  <p>
    Tulostuu:
  </p>

<pre class="sample-output">RUUTU 2
HERTTA 7
HERTTA Q
PATA 2
PATA 4
PATA A
</pre>




    </div>
  </div>
</div>



<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Elokuvien suosittelija (8 osaa)</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    <a href="https://signup.netflix.com/" target="_blank" rel="noopener">Netflix</a> lupasi lokakuussa 2006 miljoona dollaria henkilölle tai ryhmälle, joka kehittäisi ohjelman, joka on 10% parempi elokuvien suosittelussa kuin heidän oma ohjelmansa. Kilpailu ratkesi syyskuussa 2009 (<a href="http://www.netflixprize.com/" target="_blank" rel="noopener">http://www.netflixprize.com/</a>).
  </p>

  <p>
    Rakennetaan tässä tehtävässä ohjelma elokuvien suositteluun. Alla on sen toimintaesimerkki:
  </p>

<pre class="sh_java code-highlight"><code>ArvioRekisteri arviot = new ArvioRekisteri();

Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
Elokuva eraserhead = new Elokuva("Eraserhead");

Henkilo matti = new Henkilo("Matti");
Henkilo pekka = new Henkilo("Pekka");
Henkilo mikke = new Henkilo("Mikke");
Henkilo thomas = new Henkilo("Thomas");

arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
arviot.lisaaArvio(pekka, hiljaisetSillat, Arvio.HUONO);
arviot.lisaaArvio(pekka, eraserhead, Arvio.VALTTAVA);

arviot.lisaaArvio(mikke, eraserhead, Arvio.HUONO);


Suosittelija suosittelija = new Suosittelija(arviot);
System.out.println(thomas + " suositus: " + suosittelija.suositteleElokuva(thomas));
System.out.println(mikke + " suositus: " + suosittelija.suositteleElokuva(mikke));
</code></pre>

<pre class="sample-output">Thomas suositus: Hiljaiset sillat
Mikke suositus: Tuulen viemää
</pre>

  <p>
    Ohjelma osaa suositella elokuvia niiden yleisen arvion perusteella, sekä henkilökohtaisten henkilön antaminen arvioiden perusteella. Lähdetään rakentamaan ohjelmaa.
  </p>


  <h2>Henkilo ja Elokuva</h2>

  <p>
    Luo pakkaus <code>suosittelija.domain</code> ja lisää sinne luokat <code>Henkilo</code> ja <code>Elokuva</code>. Kummallakin luokalla on julkinen konstruktori <code>public <em>Luokka</em>(String nimi)</code>, sekä metodi <code>public String getNimi()</code>, joka palauttaa konstruktorissa saadun nimen.
  </p>

<pre class="sh_java code-highlight"><code>Henkilo henkilo = new Henkilo("Pekka");
Elokuva elokuva = new Elokuva("Eraserhead");

System.out.println(henkilo.getNimi() + " ja " + elokuva.getNimi());
</code></pre>

<pre class="sample-output">Pekka ja Eraserhead
</pre>

  <p>
    Lisää luokille myös <code>public String toString()</code>-metodi, joka palauttaa konstruktorissa parametrina annetun nimen, sekä korvaa metodit <code>equals</code> ja <code>hashCode</code>.
  </p>

  <p>
    Korvaa <code>equals</code> siten että samuusvertailu tapahtuu oliomuuttujan <code>nimi</code> perusteella. Metodi hashCode kannattaa generoida automaattisesti seuraavan ohjeen mukaan:
  </p>

  <p>
    <em>
      NetBeans tarjoaa metodien equals ja hashCode automaattisen luonnin. Voit valita valikosta Source -> Insert Code, ja valita aukeavasta listasta equals() and hashCode(). Tämän jälkeen NetBeans kysyy oliomuuttujat joita metodeissa käytetään.
    </em>
  </p>


  <h2>Arvio</h2>

  <p>
    Luo pakkaukseen <code>suosittelija.domain</code> lueteltu tyyppi <code>Arvio</code>. Enum-luokalla <code>Arvio</code> on julkinen metodi <code>public int getArvo()</code>, joka palauttaa arvioon liittyvän arvon. Arviotunnusten ja niihin liittyvien arvosanojen tulee olla seuraavat:
  </p>

  <table class="table">
    <tr><th>Tunnus</th><th>Arvo</th></tr>
    <tr><td>HUONO</td><td>-5</td></tr>
    <tr><td>VALTTAVA</td><td>-3</td></tr>
    <tr><td>EI_NAHNYT</td><td>0</td></tr>
    <tr><td>NEUTRAALI</td><td>1</td></tr>
    <tr><td>OK</td><td>3</td></tr>
    <tr><td>HYVA</td><td>5</td></tr>
  </table>

  <p>
    Luokkaa voi käyttää seuraavasti:
  </p>

<pre class="sh_java code-highlight"><code>Arvio annettu = Arvio.HYVA;
System.out.println("Arvio " + annettu + ", arvo " + annettu.getArvo());
annettu = Arvio.NEUTRAALI;
System.out.println("Arvio " + annettu + ", arvo " + annettu.getArvo());
</code></pre>

<pre class="sample-output">Arvio HYVA, arvo 5
Arvio NEUTRAALI, arvo 1
</pre>


  <h2>ArvioRekisteri, osa 1</h2>

  <p>
    Aloitetaan arvioiden varastointiin liittyvän palvelun toteutus.
  </p>

  <p>
    Luo pakkaukseen <code>suosittelija</code> luokka <code>ArvioRekisteri</code>, jolla on konstruktori <code>public ArvioRekisteri()</code> sekä seuraavat metodit:
  </p>

  <ul>
    <li><code>public void lisaaArvio(Elokuva elokuva, Arvio arvio)</code> lisää arviorekisteriin parametrina annetulle elokuvalle uuden arvion. Samalla elokuvalla voi olla useita samanlaisiakin arvioita.</li>
    <li><code>public List&lt;Arvio&gt; annaArviot(Elokuva elokuva)</code> palauttaa elokuvalle lisätyt arviot listana.</li>
    <li><code>public Map&lt;Elokuva, List&lt;Arvio&gt;&gt; elokuvienArviot()</code> palauttaa mapin, joka sisältää arvioidut elokuvat avaimina. Jokaiseen elokuvaan liittyy lista, joka sisältää elokuvaan lisatyt arviot.</li>
  </ul>

  <p>
    Testaa metodien toimintaa seuraavalla lähdekoodilla:
  </p>

<pre class="sh_java code-highlight"><code>Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
Elokuva eraserhead = new Elokuva("Eraserhead");

ArvioRekisteri rekisteri = new ArvioRekisteri();
rekisteri.lisaaArvio(eraserhead, Arvio.HUONO);
rekisteri.lisaaArvio(eraserhead, Arvio.HUONO);
rekisteri.lisaaArvio(eraserhead, Arvio.HYVA);

rekisteri.lisaaArvio(hiljaisetSillat, Arvio.HYVA);
rekisteri.lisaaArvio(hiljaisetSillat, Arvio.OK);

System.out.println("Kaikki arviot: " + rekisteri.elokuvienArviot());
System.out.println("Arviot Eraserheadille: " + rekisteri.annaArviot(eraserhead));
</code></pre>

<pre class="sample-output">Kaikki arviot: {Hiljaiset sillat=[HYVA, OK], Eraserhead=[HUONO, HUONO, HYVA]}
Arviot Eraserheadille: [HUONO, HUONO, HYVA]
</pre>


  <h2>ArvioRekisteri, osa 2</h2>

  <p>
    Lisätään seuraavaksi mahdollisuus henkilökohtaisten arvioiden lisäämiseen.
  </p>

  <p>
    Lisää luokkaan <code>ArvioRekisteri</code> seuraavat metodit:
  </p>

  <ul>
    <li><code>public void lisaaArvio(Henkilo henkilo, Elokuva elokuva, Arvio arvio)</code> lisää parametrina annetulle elokuvalle tietyn henkilön tekemän arvion. Sama henkilö voi arvioida tietyn elokuvan vain kertaalleen. Henkilön tekemä arvio tulee myös lisätä kaikkiin elokuviin liittyviin arvioihin.</li>
    <li><code>public Arvio haeArvio(Henkilo henkilo, Elokuva elokuva)</code> palauttaa parametrina annetun henkilön tekemän arvion parametrina annetulle elokuvalle. Jos henkilö ei ole arvioinut kyseistä elokuvaa, palauta arvio <code>Arvio.EI_NAHNYT</code>.</li>
    <li><code>public Map&lt;Elokuva, Arvio&gt; annaHenkilonArviot(Henkilo henkilo)</code> palauttaa hajautustaulun, joka sisältää henkilön tekemät arviot. Hajautustaulun avaimena on arvioidut elokuvat, arvoina arvioituihin elokuviin liittyvät arviot. Jos henkilö ei ole arvioinut yhtään elokuvaa, palautetaan tyhjä hajautustaulu.</li>
    <li><code>public List&lt;Henkilo&gt; arvioijat()</code> palauttaa listan henkilöistä jotka ovat arvioineet elokuvia.</li></ul>

  <p>
    Henkilöiden tekemät arviot kannattanee tallentaa hajautustauluun, jossa avaimena on henkilö. Arvona hajautustaulussa on toinen hajautustaulu, jossa avaimena on elokuva ja arvona arvio.
  </p>

  <p>
    Testaa paranneltua <code>ArvioRekisteri</code>-luokkaa seuraavalla lähdekoodipätkällä:
  </p>

<pre class="sh_java code-highlight"><code>ArvioRekisteri arviot = new ArvioRekisteri();

Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
Elokuva eraserhead = new Elokuva("Eraserhead");

Henkilo matti = new Henkilo("Matti");
Henkilo pekka = new Henkilo("Pekka");

arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
arviot.lisaaArvio(pekka, eraserhead, Arvio.OK);

System.out.println("Arviot Eraserheadille: " + arviot.annaArviot(eraserhead));
System.out.println("Matin arviot: " + arviot.annaHenkilonArviot(matti));
System.out.println("Arvioijat: " + arviot.arvioijat());
</code></pre>

<pre class="sample-output">Arviot Eraserheadille: [OK, OK]
Matin arviot: {Tuulen viemää=HUONO, Eraserhead=OK}
Arvioijat: [Pekka, Matti]
</pre>

  <p>
    Luodaan seuraavaksi muutama apuluokka arviointien helpottamiseksi.
  </p>


  <h2>HenkiloComparator</h2>

  <p>
    Luo pakkaukseen <code>suosittelija.comparator</code> luokka <code>HenkiloComparator</code>. Luokan <code>HenkiloComparator</code> tulee toteuttaa rajapinta <code>Comparator&lt;Henkilo&gt;</code>, ja sillä pitää olla konstruktori <code>public HenkiloComparator(Map&lt;Henkilo, Integer&gt; henkiloidenSamuudet)</code>. Luokkaa <code>HenkiloComparator</code> käytetään myöhemmin henkilöiden järjestämiseen henkilöön liittyvän luvun perusteella.
  </p>

  <p>
    HenkiloComparator-luokan tulee mahdollistaa henkilöiden järjestäminen henkilöön liittyvän luvun perusteella.
  </p>

  <p>
    Testaa luokan toimintaa seuraavalla lähdekoodilla:
  </p>

<pre class="sh_java code-highlight"><code>Henkilo matti = new Henkilo("Matti");
Henkilo pekka = new Henkilo("Pekka");
Henkilo mikke = new Henkilo("Mikke");
Henkilo thomas = new Henkilo("Thomas");

Map&lt;Henkilo, Integer&gt; henkiloidenSamuudet = new HashMap&lt;&gt;();
henkiloidenSamuudet.put(matti, 42);
henkiloidenSamuudet.put(pekka, 134);
henkiloidenSamuudet.put(mikke, 8);
henkiloidenSamuudet.put(thomas, 82);

List&lt;Henkilo&gt; henkilot = Arrays.asList(matti, pekka, mikke, thomas);
System.out.println("Henkilöt ennen järjestämistä: " + henkilot);

Collections.sort(henkilot, new HenkiloComparator(henkiloidenSamuudet));
System.out.println("Henkilöt järjestämisen jälkeen: " + henkilot);
</code></pre>

<pre class="sample-output">Henkilöt ennen järjestämistä: [Matti, Pekka, Mikke, Thomas]
Henkilöt järjestämisen jälkeen: [Pekka, Thomas, Matti, Mikke]
</pre>


  <h2>ElokuvaComparator</h2>

  <p>
    Luo pakkaukseen <code>suosittelija.comparator</code> luokka <code>ElokuvaComparator</code>. Luokan <code>ElokuvaComparator</code> tulee toteuttaa rajapinta <code>Comparator&lt;Elokuva&gt;</code>, ja sillä pitää olla konstruktori <code>public ElokuvaComparator(Map&lt;Elokuva, List&lt;Arvio&gt;&gt; arviot)</code>. Luokkaa <code>ElokuvaComparator</code> käytetään myöhemmin elokuvien järjestämiseen niiden arvioiden perusteella.
  </p>

  <p>
    ElokuvaComparator-luokan tulee tarjota mahdollisuus elokuvien järjestäminen niiden saamien arvosanojen keskiarvon perusteella. Korkeimman keskiarvon saanut elokuva tulee ensimmäisenä, matalimman keskiarvon saanut viimeisenä.
  </p>

  <p>
    Testaa luokan toimintaa seuraavalla lähdekoodilla:
  </p>

<pre class="sh_java code-highlight"><code>ArvioRekisteri arviot = new ArvioRekisteri();

Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
Elokuva eraserhead = new Elokuva("Eraserhead");

Henkilo matti = new Henkilo("Matti");
Henkilo pekka = new Henkilo("Pekka");
Henkilo mikke = new Henkilo("Mikke");

arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
arviot.lisaaArvio(pekka, hiljaisetSillat, Arvio.HUONO);
arviot.lisaaArvio(pekka, eraserhead, Arvio.VALTTAVA);

arviot.lisaaArvio(mikke, eraserhead, Arvio.HUONO);

Map&lt;Elokuva, List&lt;Arvio&gt;&gt; elokuvienArviot = arviot.elokuvienArviot();

List&lt;Elokuva&gt; elokuvat = Arrays.asList(tuulenViemaa, hiljaisetSillat, eraserhead);
System.out.println("Elokuvat ennen järjestämistä: " + elokuvat);

Collections.sort(elokuvat, new ElokuvaComparator(elokuvienArviot));
System.out.println("Elokuvat järjestämisen jälkeen: " + elokuvat);
</code></pre>

<pre class="sample-output">Elokuvat ennen järjestämistä: [Tuulen viemää, Hiljaiset sillat, Eraserhead]
Elokuvat järjestämisen jälkeen: [Hiljaiset sillat, Tuulen viemää, Eraserhead]
</pre>


  <h2>Suosittelija, osa 1</h2>

  <p>
    Toteuta pakkaukseen <code>suosittelija</code> luokka <code>Suosittelija</code>. Luokan <code>Suosittelija</code> konstruktori saa parametrinaan <code>ArvioRekisteri</code>-tyyppisen olion. Suosittelija käyttää arviorekisterissä olevia arvioita suositusten tekemiseen.
  </p>

  <p>
    Toteuta luokalle metodi <code>public Elokuva suositteleElokuva(Henkilo henkilo)</code>, joka suosittelee henkilölle elokuvia.
  </p>

  <p>
    Toteuta metodi ensin siten, että se suosittelee aina elokuvaa, jonka arvioiden arvosanojen keskiarvo on suurin. Vinkki: Tarvitset parhaan elokuvan selvittämiseen ainakin aiemmin luotua <code>ElokuvaComparator</code>-luokkaa, luokan <code>ArvioRekisteri</code> metodia <code>public Map&lt;Elokuva, List&lt;Arvio&gt;&gt; elokuvienArviot()</code>, sekä listaa olemassaolevista elokuvista.
  </p>

  <p>
    Testaa ohjelman toimimista seuraavalla lähdekoodilla:
  </p>

<pre class="sh_java code-highlight"><code>ArvioRekisteri arviot = new ArvioRekisteri();

Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
Elokuva eraserhead = new Elokuva("Eraserhead");

Henkilo matti = new Henkilo("Matti");
Henkilo pekka = new Henkilo("Pekka");
Henkilo mikke = new Henkilo("Mikael");

arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
arviot.lisaaArvio(pekka, hiljaisetSillat, Arvio.VALTTAVA);
arviot.lisaaArvio(pekka, eraserhead, Arvio.VALTTAVA);

Suosittelija suosittelija = new Suosittelija(arviot);
Elokuva suositeltu = suosittelija.suositteleElokuva(mikke);
System.out.println("Mikaelille suositeltu elokuva oli: " + suositeltu);
</code></pre>

<pre class="sample-output">Mikaelille suositeltu elokuva oli: Hiljaiset sillat
</pre>

  <p>
    Nyt tekemämme ensimmäinen vaihe toimii oikein ainoastaan henkilöille, jotka eivät ole vielä arvostelleet yhtään elokuvaa. Heidän elokuvamaustaanhan on mahdoton sanoa mitään ja paras arvaus on suositella heille keskimäärin parhaan arvosanan saanutta elokuvaa.
  </p>


  <h2>Suosittelija, osa 2</h2>

  <p>
    <em>
      Huom! Tehtävä on haastava. Kannattaa tehdä ensin muut tehtävät ja palata tähän myöhemmin. Voit palauttaa tehtäväsarjan TMC:hen vaikket saakaan tätä tehtävää tehdyksi, aivan kuten lähes kaikkien muidenkin tehtävien kohdalla.
    </em>
  </p>

  <p>
    Valitettavasti tämän osan virhediagnostiikkakaan ei ole samaa luokkaa kuin edellisissä kohdissa.
  </p>

  <p>
    Jos henkilöt ovat lisänneet omia suosituksia suosituspalveluun, tiedämme jotain heidän elokuvamaustaan. Laajennetaan suosittelijan toiminnallisuutta siten, että se luo henkilökohtaisen suosituksen jos henkilö on jo arvioinut elokuvia. Edellisessä osassa toteutettu toiminnallisuus tulee säilyttää: Jos henkilö ei ole arvioinut yhtäkään elokuvaa, hänelle suositellaan elokuva arvosanojen perusteella.
  </p>

  <p>
    Henkilökohtaiset suositukset perustuvat henkilön tekemien arvioiden samuuteen muiden henkilöiden tekemien arvioiden kanssa. Pohditaan seuraavaa taulukkoa, missä ylärivillä on elokuvat, ja vasemmalla on arvioita tehneet henkilöt. Taulukon solut kuvaavat annettuja arvioita.
  </p>

  <table class="table">
    <tr><th>Henkilo \ Elokuva</th><td>Tuulen viemää</td><td>Hiljaiset sillat</td><td>Eraserhead</td><td>Blues Brothers</td></tr>
    <tr><td>Matti</td><td>HUONO (-5)</td><td>HYVA (5)</td><td>OK (3)</td><td>-</td></tr>
    <tr><td>Pekka</td><td>OK (3)</td><td>-</td><td>HUONO (-5)</td><td>VALTTAVA (-3)</td></tr>
    <tr><td>Mikael</td><td>-</td><td>-</td><td>HUONO (-5)</td><td>-</td></tr>
    <tr><td>Thomas</td><td>-</td><td>HYVA (5)</td><td>-</td><td>HYVA (5)</td></tr>
  </table>

  <p>
    Kun haluamme hakea Mikaelille sopivaa elokuvaa, tutkimme Mikaelin samuutta kaikkien muiden arvioijien kesken. Samuus lasketaan arvioiden perusteella: samuus on kummankin katsomien elokuvien arvioiden tulojen summa. Esimerkiksi Mikaelin ja Thomasin samuus on 0, koska Mikael ja Thomas eivät ole katsoneet yhtäkään samaa elokuvaa.
  </p>

  <p>
    Mikaelin ja Pekan samuutta laskettaessa yhteisten elokuvien tulojen summa olisi 25. Mikael ja Pekka ovat katsoneet vain yhden yhteisen elokuvan, ja kumpikin antaneet sille arvosanan huono (-5).
  </p>

<pre class="sample-output">-5 * -5 = 25
</pre>

  <p>
    Mikaelin ja Matin samuus on -15. Mikael ja Matti ovat myös katsoneet vain yhden yhteisen elokuvan. Mikael antoi elokuvalle arvosanan huono (-5), Matti antoi sille arvosanan ok (3).
  </p>

<pre class="sample-output">-5 * 3 = -15
</pre>

  <p>
    Näiden perusteella Mikaelille suositellaan elokuvia Pekan elokuvamaun mukaan: suosituksena on elokuva Tuulen viemää.
  </p>

  <p>
    Kun taas haluamme hakea Matille sopivaa elokuvaa, tutkimme Matin samuutta kaikkien muiden arvioijien kesken. Matti ja Pekka ovat katsoneet kaksi yhteistä elokuvaa. Matti antoi Tuulen viemälle arvosanan huono (-5), Pekka arvosanan OK (3). Elokuvalle Eraserhead Matti antoi arvosanan OK (3), Pekka arvosanan huono (-5). Matin ja Pekan samuus on siis -30.
  </p>

<pre class="sample-output">-5 * 3 + 3 * -5 = -30
</pre>

  <p>
    Matin ja Mikaelin samuus on edellisestä laskusta tiedetty -15. Samuudet ovat symmetrisia.
  </p>

  <p>
    Matti ja Thomas ovat katsoneet Tuulen viemää, ja kumpikin antoi sille arvosanan hyvä (5). Matin ja Thomaksen samuus on siis 25.
  </p>

<pre class="sample-output">5 * 5 = 25
</pre>

  <p>
    Matille tulee siis suositella elokuvia Thomaksen elokuvamaun mukaan: suosituksena olisi Blues Brothers.
  </p>

  <p>
    Toteuta yllä kuvattu suosittelumekanismi. Jos henkilölle ei löydy yhtään suositeltavaa elokuvaa, tai henkilö, kenen elokuvamaun mukaan elokuvia suositellaan on arvioinut elokuvat joita henkilö ei ole vielä katsonut huonoiksi, välttäviksi tai neutraaleiksi, palauta metodista <code>suositteleElokuva</code> arvo <code>null</code>. Edellisessä tehtävässä määritellyn lähestymistavan tulee toimia jos henkilö ei ole lisännyt yhtäkään arviota.
  </p>

  <p>
    Älä suosittele elokuvia, jotka henkilö on jo nähnyt.
  </p>

  <p>
    Voit testata ohjelmasi toimintaa seuraavalla lähdekoodilla:
  </p>

<pre class="sh_java code-highlight"><code>ArvioRekisteri arviot = new ArvioRekisteri();

Elokuva tuulenViemaa = new Elokuva("Tuulen viemää");
Elokuva hiljaisetSillat = new Elokuva("Hiljaiset sillat");
Elokuva eraserhead = new Elokuva("Eraserhead");
Elokuva bluesBrothers = new Elokuva("Blues Brothers");

Henkilo matti = new Henkilo("Matti");
Henkilo pekka = new Henkilo("Pekka");
Henkilo mikke = new Henkilo("Mikael");
Henkilo thomas = new Henkilo("Thomas");
Henkilo arto = new Henkilo("Arto");

arviot.lisaaArvio(matti, tuulenViemaa, Arvio.HUONO);
arviot.lisaaArvio(matti, hiljaisetSillat, Arvio.HYVA);
arviot.lisaaArvio(matti, eraserhead, Arvio.OK);

arviot.lisaaArvio(pekka, tuulenViemaa, Arvio.OK);
arviot.lisaaArvio(pekka, eraserhead, Arvio.HUONO);
arviot.lisaaArvio(pekka, bluesBrothers, Arvio.VALTTAVA);

arviot.lisaaArvio(mikke, eraserhead, Arvio.HUONO);

arviot.lisaaArvio(thomas, bluesBrothers, Arvio.HYVA);
arviot.lisaaArvio(thomas, hiljaisetSillat, Arvio.HYVA);

Suosittelija suosittelija = new Suosittelija(arviot);
System.out.println(thomas + " suositus: " + suosittelija.suositteleElokuva(thomas));
System.out.println(mikke + " suositus: " + suosittelija.suositteleElokuva(mikke));
System.out.println(matti + " suositus: " + suosittelija.suositteleElokuva(matti));
System.out.println(arto + " suositus: " + suosittelija.suositteleElokuva(arto));
</code></pre>

<pre class="sample-output">Thomas suositus: Eraserhead
Mikael suositus: Tuulen viemää
Matti suositus: Blues Brothers
Arto suositus: Hiljaiset sillat
</pre>

  <p>
    Miljoona käsissä? Ei ehkä vielä. Tietojenkäsittelytieteen tekoäly- ja koneoppimiskursseilla opitaan lisää tekniikoita oppivien järjestelmien rakentamiseen.
  </p>



    </div>
  </div>
</div>


















<h1 class="material-heading">
    Lisää rajapinnoista

</h1>

<p>
  Rajapinta määrittelee yhden tai useamman metodin, jotka rajapinnan toteuttavan luokan on pakko toteuttaa. Rajapintoja, kuten kaikkia luokkia voi asettaa pakkauksiin. Esimerkiksi seuraava <code>Tunnistettava</code>-rajapinta sijaitsee pakkauksessa <code>sovellus.domain</code>. Rajapinta määrää, että <code>Tunnistettava</code>-rajapinnan toteuttavien luokkien tulee toteuttaa metodi <code>public String getTunnus()</code>.</p>

<pre class="sh_java code-highlight"><code>package sovellus.domain;

public interface Tunnistettava {
String getTunnus();
}
</code></pre>

<p>
  Luokka toteuttaa rajapinnan <code>implements</code>-avainsanalla. Alla on esimerkkinä luokka <code>Henkilo</code>, joka toteuttaa rajapinnan tunnistettava. Rajapinnan Tunnistettava vaatima metodi <code>getTunnus</code> palauttaa aina henkilön henkilötunnuksen.
</p>

<pre class="sh_java code-highlight"><code>package sovellus.domain;

public class Henkilo implements Tunnistettava {
private String nimi;
private String henkilotunnus;

public Henkilo(String nimi, String henkilotunnus) {
this.nimi = nimi;
this.henkilotunnus = henkilotunnus;
}

public String getNimi() {
return this.nimi;
}

public String getHenkilotunnus() {
return this.henkilotunnus;
}

@Override
public String getTunnus() {
return getHenkilotunnus();
}

@Override
public String toString() {
return this.nimi + " hetu: " + this.henkilotunnus;
}
}
</code></pre>


<p>
  Rajapintojen vahvuus on se, että rajapintaa voidaan käyttää muuttujan tyyppinä. Tämä mahdollistaa yleiskäyttöisempien luokkien tekemisen.
</p>

<p>
  Tehdään luokka <code>Rekisteri</code>, jota käytetään Tunnistettava-tyyppisten olioiden säilömiseen. Rekisteriin voidaan lisätä sekä henkilöitä että mitä tahansa muita olioita, jotka toteuttavat rajapinnan Tunnistettava. Yksittäisten henkilöiden hakemisen lisäksi <code>Rekisteri</code> tarjoaa metodin kaikkien henkilöiden hakemiseen listana.
</p>

<pre class="sh_java code-highlight"><code>public class Rekisteri {
private Map&lt;String, Tunnistettava&gt; rekisteroidyt;

public Rekisteri() {
this.rekisteroidyt = new HashMap&lt;&gt;();
}

public void lisaa(Tunnistettava lisattava) {
this.rekisteroidyt.put(lisattava.getTunnus(), lisattava);
}

public Tunnistettava hae(String tunnus) {
return this.rekisteroidyt.get(tunnus);
}

public List&lt;Tunnistettava&gt; haeKaikki() {
return new ArrayList&lt;Tunnistettava&gt;(rekisteroidyt.values());
}
}</code></pre>


<p>
  Rekisterin käyttö onnistuu seuraavasti.
</p>

<pre class="sh_java code-highlight"><code>Rekisteri henkilokunta = new Rekisteri();
henkilokunta.lisaa(new Henkilo("Pekka", "221078-123X"));
henkilokunta.lisaa(new Henkilo("Jukka", "110956-326B"));

System.out.println(henkilokunta.hae("280283-111A"));

Henkilo loydetty = (Henkilo) henkilokunta.hae("110956-326B");
System.out.println(loydetty.getNimi());
</code></pre>

<p>
  Koska henkilöt on lisätty rekisteriin <code>Tunnistettava</code>-tyyppisinä, ne löytyvät sieltä myös Tunnistettava-tyyppisinä. Jos haluamme käsitellä henkilöitä sellaisten metodien kautta, joita rajapinnassa ei ole määritelty, joudumme muuntamaan ne takaisin Henkilo-olioiksi. Tämä tapahtuu eksplisiittisella tyyppimuunnoksella, jota demonstroidaan edellisen esimerkin kahdella viimeisellä rivillä.
</p>

<p>
  Entä jos haluaisimme rekisteriin lisäksi metodin, joka palauttaa rekisteriin talletetut henkilöt tunnisteen mukaan järjestettynä? Yksi vaihtoehto olisi käyttää aiemmin tutuksi tullutta virran järjestämistä. Tutustutaan kuitenkin myös Javan valmiiseen järjestämisessä käytettävään rajapintaan.
</p>



<h2 class="material-heading">
    Useamman rajapinnan toteuttaminen

</h2>

<p>
  Kokeillaan lisätä aiemmin luomallemme Rekisteri-luokalle metodi haeKaikkiJarjestyksessa.
</p>

<pre class="sh_java code-highlight"><code>public List&lt;Tunnistettava&gt; haeKaikkiJarjestyksessa() {
// ei toimi!
return rekisteroidyt.values()
.stream().sorted().collect(Collectors.toCollection(ArrayList::new));
}
</code></pre>

<p>
  Metodi ei kuitenkaan toimi. Koska henkilöt on talletettu rekisteriin <code>Tunnistettava</code>-tyyppisinä, on Henkilön toteutettava rajapinta <code>Comparable&lt;Tunnistettava&gt;</code>, jotta rekisteri osaisi järjestää henkilöt tunnistettavina. Joudumme joko muuttamaan henkilön toteuttamaa rajapintaa, tai lisäämään <code>sorted</code>-metodille järjestämiseen käytettävät tiedot. Muutetaan tässä henkilön toteuttamaa rajapintaa:
</p>

<pre class="sh_java code-highlight"><code>public class Henkilo implements Tunnistettava, Comparable&lt;Tunnistettava&gt; {
// ...

@Override
public int compareTo(Tunnistettava toinen) {
return this.getTunnus().compareTo(toinen.getTunnus());
}
}</code></pre>


<p>
  Nyt ratkaisu toimii!
</p>

<p>
  Rekisteri on täysin tietämätön sinne lisättyjen olioiden todellisesta tyypistä. Voimme käyttää luokkaa rekisteri myös muuntyyppisten olioiden kuin henkilöiden rekisteröintiin, kunhan olioiden luokka vaan toteuttaa rajapinnan <code>Tunnistettava</code>. Esim. seuraavassa käytetään rekisteriä kaupassa myytävien tuotteiden hallintaan:
</p>

<pre class="sh_java code-highlight"><code>public class Tuote implements Tunnistettava {

private String nimi;
private String viivakoodi;
private int varastosaldo;
private int hinta;

public Tuote(String nimi, String viivakoodi) {
this.nimi = nimi;
this.viivakoodi = viivakoodi;
}

public String getTunnus() {
return viivakoodi;
}

// ...
}
</code></pre>


<pre class="sh_java code-highlight"><code>Rekisteri tuotteet = new Rekisteri();
tuotteet.lisaa(new Tuote("maito", "11111111"));
tuotteet.lisaa(new Tuote("piimä", "11111112"));
tuotteet.lisaa(new Tuote("juusto", "11111113"));

System.out.println(tuotteet.hae("99999999"));

Tuote tuote = (Tuote) tuotteet.hae("11111112");
tuote.kasvataSaldoa(100);
tuote.muutaHinta(23);
</code></pre>

<p>
  Teimme luokasta <code>Rekisteri</code> melko yleiskäyttöisen pitämällä sen riippumattomana konkreettisista luokista. Mikä tähänsa luokka, joka toteuttaa rajapinnan <code>Tunnistettava</code>, on rekisterin kanssa käyttökelpoinen. Metodin <code>haeKaikkiJarjestyksessä</code> toimiminen tosin edellyttää luokalta myös vertailtavuuden eli Comparable&lt;Tunnistettava&gt;-rajapinnan toteuttamisen.
</p>


<div class="hint">
  <div class="hint__header">
    <i class="fa fa-info-circle hint__icon"></i>Muutama NetBeans-vihje
  </div>

  <div class="hint__body">
    
  <ul>
    <li> <strong>Implement all abstract methods</strong>

      <p>
	Voit pyytää NetBeansia täydentämään metodirungot automaattisesti rajapinnan toteuttavalle luokalle. Kun olet määritellyt luokan toteuttavan rajapinnan, eli kirjoittanut
      </p>

<pre class="sh_java code-highlight"><code>	public class Luokka implements Rajapinta {
	}
</code></pre>

      <p>
	NetBeans värjää luokan nimen punaisella. Mene rivin vasemmassa reunassa olevan lamppusymbolin kohdalle, klikkaa ja valitse <em>Implement all abstract methods</em> ja metodirungot ilmestyvät koodiin!
      </p>

    </li>

    <li> <strong>Clean and Build</strong>

      <p>
	Tietyissä tilanteissa NetBeans saattaa mennä sekaisin ja yrittää ajaa koodista versiota johon ei ole huomioitu kaikkia koodiin kirjoitettuja muutoksia. Yleensä huomaat tilanteen siten, että jotain "outoa" vaikuttaa tapahtuvan. Ongelman korjaa usein <em>Clean and build</em> -operaation suorittaminen. Operaatio löytyy Run-valikosta ja sen voi suorittaa myös painamalla <em>harja ja vasara</em> -symbolia. Clean and build poistaa koodista olemassa olevat käännetyt versiot ja tekee uuden käännöksen.
      </p>

    </li>

  </ul>


  </div>
</div>


<h2 class="material-heading">
    Oletusmetodit rajapinnoissa

</h2>

<p>
  Rajapintoihin voi määritellä oletusmetodeja, joiden mukana annetaan myös toteutus. Oletusmetodien määrittely alkaa avainsanalla <code>default</code>, jota seuraa metodin määrittely. Kuten rajapintojen metodeissa yleensä, myös tässäkään näkyvyyttä ei tarvitse määritellä erikseen. Rajapinnoissa määriteltyjen metodien näkyvyys on aina <code>public</code>.
</p>

<p>
  Alla olevassa esimerkissä rajapintaan <code>Luettava</code> on lisätty oletusmetodi <code>lueTulostaen</code>, joka tulostaa <code>lue</code>-metodin palauttaman arvon.
</p>

<pre class="sh_java code-highlight"><code>public interface Luettava {
String lue();

default void lueTulostaen() {
System.out.println(lue());
}
}
</code></pre>

<p>
  Yksi oletusmetodien suurimmista hyödyistä ilmenee tilanteissa, missä rajapinta on määritelty aiemmin, ja useampi luokka toteuttaa sen jo valmiiksi. Jos rajapintaan lisätään uusi metodi, tulee sille ohjelmoida toteutus kaikkiin rajapinnan toteuttamiin luokkiin, jos uusi metodi ei tarjoa oletustoteutusta.
</p>

<p>
  Toisaalta, jos oletustoteutus lisätään uuden metodin lisäämisen yhteydessä, ei aiemmin rajapinnan toteuttaneille luokille tarvitse tehdä minkäänlaisia muutoksia. Edellisestä osasta tutut luokat Tekstiviesti ja Sahkoposti toimisivat nyt myös seuraavasti.
</p>

<pre class="sh_java code-highlight"><code>Tekstiviesti viesti = new Tekstiviesti("G. Hopper", "COBOL kicks ass");
viesti.lueTulostaen();

Sahkoposti posti = new Sahkoposti("D. Knuth", "If you optimize everything, you will always be unhappy.");
posti.lueTulostaen();
</code></pre>

<pre class="sample-output">COBOL kicks ass
If you optimize everything, you will always be unhappy.
</pre>





<h2 class="material-heading">
    Lukeminen verkkoyhteyden yli

</h2>

<p>
  Lähes kaikki verkkosivut, kuten tämäkin oppimateriaali, voidaan lukea tekstimuodossa ohjelmallista käsittelyä varten. Scanner-oliolle voi antaa konstruktorin parametrina lähes minkälaisen syötevirran tahansa. Alla olevassa esimerkissä luodaan URL-olio annetusta web-osoitteesta, pyydetään siihen liittyvää tietovirtaa, ja annetaan se uudelle Scanner-oliolle luettavaksi.
</p>


<pre class="sh_java code-highlight"><code>ArrayList&lt;String&gt; rivit = new ArrayList&lt;&gt;();

// luodaan lukija web-osoitteen lukemista varten
try (Scanner lukija = new Scanner(new URL("http://www.cs.helsinki.fi/home/").openStream())) {

    // luetaan osoitteesta http://www.cs.helsinki.fi/home/
    // saatava vastaus
    while (lukija.hasNextLine()) {
        rivit.add(lukija.nextLine());
    }
} catch (Exception e) {
    System.out.println("Virhe: " + e.getMessage());
}

// tehdään jotain vastauksella
</code></pre>

<p>
  Web-selain on oikeastaan ohjelma siinä missä muutkin ohjelmat. Toisin kuin yllä toteutettu sivun sisällön lataaja, web-selaimeen on toteutettu toiminnallisuus vastauksena tulevan HTML-muotoisen lähdekoodin tulkisemiseen ja graafisessa käyttöliittymässä näyttämiseen.
</p>


<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Chuck Norris -vitsit</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Osoitteessa <a href="http://www.icndb.com/api/" target="_blank" rel="noopener">http://www.icndb.com/api/</a> sijaitsee web-sovellus, joka tarjoaa Chuck Norris -vitsejä kaikkien vapaaseen käyttöön.
  </p>

  <p>
    Sovellus tarjoaa muunmuassa mahdollisuuden satunnaisten vitsien hakemiseen (osoite <code>http://api.icndb.com/jokes/random</code>) sekä vitsien hakemiseen niihin liittyvillä numeerisilla tunnuksilla (osoite <code>http://api.icndb.com/jokes/<em>tunnus</em></code>, missä <em>tunnus</em> on kokonaisluku).
  </p>

  <p>
    Toteuta sovellus, joka tarjoaa kolme toimintoa. Jos käyttäjä kirjoittaa "lopeta", ohjelman suoritus lopetetaan. Jos käyttäjä kirjoittaa "satunnainen", ohjelma tulostaa icndb-palvelusta noudetun satunnaisen chuck norris vitsin. Jos käyttäjä kirjoittaa "vitsi <em>numero</em>", missä numero on kokonaisluku, ohjelma tulostaa icndb-palvelusta noudetun tietyn vitsin.
  </p>

  <p>
    Huom! Tässä tehtävässä riittää tulostaa palvelun palauttama merkkijono kokonaisuudessaan. Merkkijono voi olla esimerkiksi muotoa <code>{ "type": "success", "value": { "id": 341, "joke": "Chuck Norris sleeps with a pillow under his gun.", "categories": [] } }</code>.
  </p>

  <p>
    Ohjelmassa ei ole testejä, eli testit eivät ota kantaa sovelluksen rakenteeseen tai tulostuksen ulkoasuun. Palauta sovellus kun se toimii koneellasi toivotulla tavalla.
  </p>



    </div>
  </div>
</div>



<h1 class="material-heading">
    Merkkijonojen käsittely

</h1>

- charat
- indexOf
- substring

- split -> taulukko


--- 



<h2 class="material-heading">
    Merkkijonon... metodit?

</h2>

<p>
  Merkkijonot poikkeavat luonteeltaan hieman esimerkiksi kokonaisluvuista. Kokonaisluvut ovat "pelkkiä arvoja" -- niiden avulla voi tehdä laskutoimituksia ja niiden arvon voi tulostaa:
</p>

<pre class="sh_java code-highlight"><code>int x = 1;
int y = 3;

y = 3 * x + 2;

System.out.println("y:n arvo nyt: " + y);
</code></pre>

<pre class="sample-output">y:n arvo nyt: 5
</pre>

<p>
  Merkkijonot taas ovat hieman "älykkäämpiä" ja tietävät esimerkiksi pituutensa:
</p>

<pre class="sh_java code-highlight"><code>String sana1 = "Ohjelmointi";
String sana2 = "Java";

System.out.println("merkkijonon " + sana1 + " pituus: " + sana1.length());
System.out.println("merkkijonon " + sana2 + " pituus: " + sana2.length());
</code></pre>

<p>
  Tulostuu:
</p>

<pre class="sample-output">merkkijonon Ohjelmointi pituus on 11
merkkijonon Java pituus on 4
</pre>

<p>
  Pituus saadaan selville kutsumalla merkkijonon metodia <code>length()</code>. Merkkijonoilla on joukko muitakin metodeja. Kokonaisluvuilla eli <code>int</code>:eillä ei ole metodeja ollenkaan, ne eivät itsessään "osaa" mitään. Mistä tässä oikein on kyse?
</p>


<h2 class="material-heading">
    Olioihin liittyy sekä metodeja että arvoja

</h2>

<p>
  Merkkijonot ovat olioita, joihin liittyy sekä merkkijonon teksti että metodeja, joilla tekstiä voi käsitellä. Termi <strong>olio</strong> tarkoittaa tietynlaista muuttujaa. Jatkossa tulemme näkemään hyvin paljon muitakin olioita kuin merkkijonoja.
</p>

<p>
  Olion metodia kutsutaan lisäämällä muuttujan nimen perään piste ja metodin nimi. Näiden lisäksi tulee sulut sekä mahdolliset parametrit:
</p>

<pre class="sh_java code-highlight"><code>String sana1 = "Ohjelmointi";
String sana2 = "Java";

sana1.length();    // kutsutaan merkkijono-olion sana1 metodia length()
sana2.length();    // kutsutaan merkkijono-olion sana2 metodia length()
</code></pre>

<p>
  Metodikutsu kohdistuu nimenomaan siihen olioon, mille metodia kutsutaan. Yllä kutsumme ensin <code>sana1</code>-nimisen merkkijonon <code>length()</code>-metodia, sitten merkkijonon <code>sana2</code> metodia <code>length()</code>.</p>

<p>
  Vanha tuttumme <code>lukija</code> on myös olio:
</p>

<pre class="sh_java code-highlight"><code>Scanner lukija = new Scanner(System.in);
</code></pre>

<p>
  Lukijat ja merkkijonot ovat molemmat oliota, mutta ne ovat kuitenkin varsin erilaisia. Lukijoilla on mm. metodi <code>nextLine()</code> jota merkkijonoilla ei ole. Javassa oliot "synnytetään" eli luodaan melkein aina komennolla <code>new</code>, merkkijonot muodostavat tässä suhteessa poikkeuksen! -- Merkkijonoja voi luoda kahdella tavalla:
</p>

<pre class="sh_java code-highlight"><code>String banaani = new String("Banaani");
String porkkana = "porkkana";
</code></pre>

<p>
  Kumpikin ylläolevista riveistä luo uuden merkkijono-olion. Merkkijonojen luonnissa <code>new</code>-komentoa käytetään kuitenkin hyvin harvoin, sillä Java-ohjelmointikielen toteuttajat ovat tehneet merkkijonojen luomiseen lyhyemmän (ei new-komentoa tarvitsevan) tavan.
</p>

<p>
  Olion "tyypistä" puhuttaessa puhutaan usein <em>luokista</em>. Merkkijonojen luokka on <code>String</code>, lukijoiden luokka taas on <code>Scanner</code>. Opimme jatkossa luokista ja olioista paljon lisää.
</p>



<h2 class="material-heading">
    Monimutkaisemman tiedon lukeminen

</h2>

<p>
  Edellisessä esimerkissä sekä sitä seuranneissa tehtävissä tiedoston sisältö käsiteltiin riveittäin lukuina tai merkkijonoina. Mikäli tiedosto noudattaa jonkinlaista ennalta määrättyä rakennetta ja sen sisältämä tieto liittyy konkreettiseen käsitteeseen, voidaan luetut rivit muuttaa myös olioiksi.
</p>

<p>
  Oletetaan, että käytössämme on seuraavaa muotoa noudattava reseptejä sisältävä tiedosto. Tiedosto sisältää aina ensin reseptin nimen, jota seuraa reseptiin liittyvät raaka-aineet. Raaka-aineita seuraa tyhjä rivi, jonka jälkeen alkaa uusi resepti. Tiedoston muoto on siis seuraava
</p>

<pre class="sample-output">Reseptin 1 nimi
reseptin 1 raaka-aine 1
reseptin 1 raaka-aine 2

Reseptin 2 nimi
reseptin 2 raaka-aine 1
reseptin 2 raaka-aine 2
reseptin 2 raaka-aine 3
reseptin 2 raaka-aine 4

Reseptin 3 nimi
reseptin 3 raaka-aine 1
reseptin 3 raaka-aine 2
reseptin 3 raaka-aine 3
reseptin 3 raaka-aine 4
</pre>

<p>
  Käsitettä <code>Resepti</code> voidaan luoda kuvaamaan seuraavanlainen luokka, joka sisältää sekä nimen että listan raaka-aineita.
</p>

<pre class="sh_java code-highlight"><code>import java.util.ArrayList;

public class Resepti {
    private String nimi;
    private ArrayList&lt;String&gt; raakaAineet;

    public Resepti(String nimi) {
        this.nimi = nimi;
        this.raakaAineet = new ArrayList&lt;&gt;();
    }

    public void lisaaRaakaAine(String raakaAine) {
        this.raakaAineet.add(raakaAine);
    }

    public String toString() {
        String palautettava = this.nimi;
        for (String raakaAine: this.raakaAineet) {
            palautettava += "\n  " + raakaAine;
        }
        return palautettava;
    }
}
</code></pre>

<pre class="sh_java code-highlight"><code>Resepti resepti = new Resepti("Lettutaikina");
resepti.lisaaRaakaAine("0.5 litraa maitoa");
resepti.lisaaRaakaAine("2 munaa");
resepti.lisaaRaakaAine("sopivasti jauhoa");
resepti.lisaaRaakaAine("0.5 tl suolaa");
resepti.lisaaRaakaAine("2 rkl sokeria");
resepti.lisaaRaakaAine("voita paistamiseen");

System.out.println(resepti);
</code></pre>

<pre class="sample-output">Lettutaikina
  0.5 litraa maitoa
  2 munaa
  sopivasti jauhoa
  0.5 tl suolaa
  2 rkl sokeria
  voita paistamiseen
</pre>

<p>
  Nyt tiedoston lukeminen onnistuu seuraavasti.
</p>


<pre class="sh_java code-highlight"><code>ArrayList&lt;Resepti&gt; reseptit = new ArrayList&lt;&gt;();
Scanner lukija = new Scanner(System.in);
System.out.println("Mistä tiedostosta luetaan?");
String tiedosto = lukija.nextLine();

try (Scanner tiedostonLukija = new Scanner(new File(tiedosto))) {

    // luetaan reseptit ja raaka-aineet
    while (tiedostonLukija.hasNextLine()) {
        // luetaan resepti ja luodaan sitä vastaava olio
        String reseptinNimi = tiedostonLukija.nextLine();
        Resepti resepti = new Resepti(reseptinNimi);

        // lisätään resepti listalle
        reseptit.add(resepti);

        // lisätään reseptiin raaka-aineet
        while (tiedostonLukija.hasNextLine()) {
            String raakaAine = tiedostonLukija.nextLine();

            // reseptin raaka-aineet lopetetaan tyhjällä rivillä
            if(raakaAine.isEmpty()) {
                // poistutaan tästä while-toistolauseesta
                // (ulompi jatkaa)
                break;
            }

            resepti.lisaaRaakaAine(raakaAine);
        }

    }
} catch (Exception e) {
    System.out.println("Virhe: " + e.getMessage());
}

// tee jotain luetuilla resepteillä
</code></pre>


<div class="quiznator-plugin" data-quiz-id="5a874484c1b9900004293f60"></div>


<div class="quiznator-plugin" data-quiz-id="5a87457fc1b9900004293f62"></div>


<div class="quiznator-plugin" data-quiz-id="5a8745e7c1b9900004293f63"></div>







https://medium.com/@_marcos_otero/the-real-10-algorithms-that-dominate-our-world-e95fa9f16c04


<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Round-robin</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Tietokoneella voi olla samaan aikaan käynnissä useita ohjelmia, mutta todellisuudessa kaikkien käynnissä olevien ohjelmien lähdekoodia ei suoriteta samaan aikaan. Tietokoneen käyttöjärjestelmä vaihtaa suoritettavaa ohjelmaa jatkuvasti, minkä kautta käyttäjälle tulee illuusio siitä, että ohjelmat olisivat samaan aikaan käynnissä.
  </p>

  <p>
    <a href="https://en.wikipedia.org/wiki/Round-robin_scheduling" target="_blank" rel="noopener">Round-robin -algoritmia</a> käytetään tietokoneen ohjelmien aikatauluttamiseen.
  </p>

  <p>
    Algoritmin toimintaperiaate on yksinkertainen. Ohjelmista luodaan jono, ja ensimmäisenä jonossa olevaa ohjelmaa suoritetaan hetki, jonka jälkeen suoritettavana ollut ohjelma siirretään jonon perälle. Tämän jälkeen seuraava jonossa ollut ohjelma -- nyt jonon ensimmäinen -- päätyy suoritettavaksi, jonka jälkeen se siirretään jonon perälle jne.
  </p>

  <p>
    Tehtäväpohjassa on viisi lukua sisältävä taulukko sekä ohjelmarunko niiden käsittelyyn. Ohjelmarunko tuntee tällä hetkellä kaksi komentoa: "lopeta" lopettaa ohjelman suorituksen ja "tulosta" tulostaa taulukon arvot.
  </p>

  <p>
    Lisää ohjelmaan komento "siirra", joka siirtää ensimmäisenä taulukossa olevan arvon taulukon perälle sekä kaikkia muita taulukon arvoja yhden paikan eteenpäin.
  </p>

<pre class="sample-output"><font color="red">tulosta</font>
1 3 5 7 9
<font color="red">siirra</font>
<font color="red">tulosta</font>
3 5 7 9 1
<font color="red">siirra</font>
<font color="red">siirra</font>
<font color="red">tulosta</font>
7 9 1 3 5
<font color="red">lopeta</font>
</pre>



    </div>
  </div>
</div>




<h1 class="material-heading">
    Alkeis- ja viittaustyyppiset muuttujat tietokoneen näkökulmasta

</h1>

<p>
   Sanoessamme "muuttujaan asetetaan arvo.." tai "muuttujan arvoksi kopioidaan.." käytämme ohjelmoijien käyttämää kieltä. 
   
   Ohjelmoijien kieli on kuitenkin abstraktio tietokoneen sisäisestä toiminnasta. Tarkastellaan tässä lyhyesti mitä 
</p>

<p>
Ohjelmointikieli on abstraktio mikä mahdollistaa ohjelmointiin liittyvistä asioista puhumisen abstraktioiden avulla.
</p>

<p>
  Aiheeseen syvennytään tarkemmin kurssilla tietokoneen toiminta.
</p>

<p>
  Tänne bittijutut sekä muisti jne. 
</p>

this vs super

extends vai implements


<div class="hint">
  <div class="hint__header">
    <i class="fa fa-info-circle hint__icon"></i>Bitit ja binääriluvut
  </div>

  <div class="hint__body">
    
  <p>
    Tietokoneen muisti on käytännössä taulukko, missä jokainen taulukon lokero sisältää joko luvun 0 tai 1. Näitä yksittäisiä lukuja kutsutaan biteiksi (lyhenne sanasta binary digit). Koneen käyttämät luvut kuvataan bittien avulla binäärilukuina. Esimerkiksi <code>short</code>-tyyppinen muuttuja sisältää 16 bittiä ja <code>int</code>-tyyppinen muuttuja 32 bittiä. TODO: miten string-muodostuu
  </p>

  <p>
    Tarkastellaan miten binääriluvut toimivat. Alla on kuvattuna 8 bittiä pitkä alue tietokoneen muistista, missä jokainen bitin arvo on 0. 
  </p>

  <table border="1">
    <tr>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
  </table>

  <br/>
  
  <p>
    Binäärilukukujen avulla jokainen luku voidaan esittää luvun 2 potensseina. Esimerkiksi yllä olevan kahdeksan bitin luvun arvo kymmenjärjestelmässä on: 0 * 2<sup>0</sup> + 0 * 2<sup>1</sup> + ... + 0 * 2<sup>7</sup> = 0. Laskeminen aloitetaan tyypillisesti luvun oikeasta laidasta. Alla on kuvattuna toinen esimerkki.
  </p>
  
  <table border="1">
    <tr>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
  </table>

  <br/>
  
  <p>
    Yllä kuvattu binääriluku on kymmenjärjestelmässä: 1 * 2<sup>0</sup> + 0 * 2<sup>1</sup> + 1 * 2<sup>2</sup> + 0 * 2<sup>3</sup> + ... + 0 * 2<sup>7</sup> = 5. 
  </p>

  <p>
    Vastaavasti kymmenjärjestelmän luku 3 voidaan ilmaista binäärilukuna "11", ja esimerkiksi luku 256 binäärilukuna "100000000". Binäärilukujen avulla kuvataan lukujen lisäksi käytännössä kaikki tietokoneen tallentama tieto. Tähän teemaan tutustutaan tarkemmin kurssilla Tietokoneen toiminta (TKT-10005). 
  </p>

  <p>
    TODO: tieto muistissa -- muuttuja on osoite paikkaan; int-muuttujan arvon saa selville lukemalla 32 bittiä int-muuttujan arvon kuvaamasta paikasta lähtien.
  </p>


  </div>
</div>


<p>
  TODO: jatkokurssille moniulotteiset taulukot
</p>


<h2 class="material-heading">
    Kaksiulotteinen taulukko

</h2>

<p>
  Aiemmat taulukkoesimerkkimme ovat käsitelleet yksiulotteisia taulukoita, missä indeksi kertoo sijainnin yhdessä ulottuvuudessa. Taulukon voi luoda myös useampiulotteisena, jolloin taulukossa olevaa tietoa voi tarkastella useamman indeksin avulla. Tämä on kätevää esimerkiksi silloin, jos tieto on useampiulotteista kuten esimerkiksi koordinaatistossa.
</p>

<p>
  Kaksiulotteinen taulukko, jossa on kaksi riviä ja kolme saraketta, luodaan seuraavasti:
</p>

<pre class="sh_java code-highlight"><code>int rivit = 2;
int sarakkeet = 3;
int[][] kaksiulotteinenTaulukko = new int[rivit][sarakkeet];
</code></pre>

<p>
  Yllä luomme taulukon, jonka jokainen rivi viittaa taulukkoon, jossa on tietty määrä sarakkeita. Kaksiulotteisen taulukon läpikäynti onnistuu kahden sisäkkäisen while-toistolauseen avulla seuraavasti:
</p>

<pre class="sh_java code-highlight"><code>int rivit = 2;
int sarakkeet = 3;
int[][] kaksiulotteinenTaulukko = new int[rivit][sarakkeet];

int y = 0;
while (y &lt; kaksiulotteinenTaulukko.length) {

    int x = 0;
    while (x &lt; kaksiulotteinenTaulukko[y].length) {
        int arvo = kaksiulotteinenTaulukko[y][x];
        System.out.println("arvo kohdassa (" + x + ", " + y + "): " + arvo);
        x++;
    }

    y++;
}
</code></pre>

<p>
  Ylläolevan ohjelman tulostus on seuraava.
</p>

<pre class="sample-output">arvo kohdassa (0, 0): 0
arvo kohdassa (1, 0): 0
arvo kohdassa (2, 0): 0
arvo kohdassa (0, 1): 0
arvo kohdassa (1, 1): 0
arvo kohdassa (2, 1): 0
</pre>

<p>
  Saatoit yllättyä. Selityksenä tulostukselle on se, että int-tyyppisten muuttujien oletusarvo on 0.
</p>

<p>
  Voimme muuttaa taulukon arvoja kuten ennenkin. Alla asetamme kahteen kohtaan uudet arvot.
</p>

<pre class="sh_java code-highlight"><code>int rivit = 2;
int sarakkeet = 3;
int[][] kaksiulotteinenTaulukko = new int[rivit][sarakkeet];

kaksiulotteinenTaulukko[0][1] = 4;
kaksiulotteinenTaulukko[1][1] = 1;
kaksiulotteinenTaulukko[1][0] = 8;


int y = 0;
while (y &lt; kaksiulotteinenTaulukko.length) {

    int x = 0;
    while (x &lt; kaksiulotteinenTaulukko[y].length) {
        int arvo = kaksiulotteinenTaulukko[y][x];
        System.out.println("arvo kohdassa (" + x + ", " + y + "): " + arvo);
        x++;
    }

    y++;
}
</code></pre>

<p>
  Nyt tulostus näyttää seuraavalta:
</p>

<pre class="sample-output">arvo kohdassa (0, 0): 0
arvo kohdassa (1, 0): 4
arvo kohdassa (2, 0): 0
arvo kohdassa (0, 1): 8
arvo kohdassa (1, 1): 1
arvo kohdassa (2, 1): 0
</pre>

<p>
  Kaksiulotteinen taulukko on oikeastaan <a href="https://fi.wikipedia.org/wiki/Matriisi" target="_blank" rel="noopener">matriisi</a>.  Matriiseja käytetään muunmuassa tietokonegrafiikassa, missä yksittäiset pikselit esitetään matriisin avulla.</p>


<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Piirto-ohjelma</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Tehtäväpohjaan on toteutettu graafinen sovellus, mikä sisältää kaksiulotteisen taulukon. Tehtävänäsi on muuttaa sovelluksen toimintaa siten, että kun käyttäjä painaa hiirtä sovelluksessa tai liikuttaa hiirtä kun nappi on pohjassa, ikkunaan piirretään.
  </p>

  <p>
    Tee tätä varten kaksi asiaa: (1) muuta sovelluksessa olevan taulukon "piirrettava" arvoja sopivasti kun käyttäjä käyttää hiirtä, ja (2) piirrä komentoa <code>piirturi(x, y, 2, 2)</code> käyttäen ne alkiot, joiden arvo on 1. Käytä koordinaatteina x, y taulukon indeksejä.
  </p>

  <p>
    Kun sovellus toimii, voit käyttää sitä vaikkapa seuraavanlaisen taideteoksen tekemiseen. Tehtävässä ei ole testejä.
  </p>

  <img src="../img/exercises/06-14-piirturi-ok-c83b2ab7.png" />




    </div>
  </div>
</div>


<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Game of Life (2 osaa)</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Toteutimme aiemmin Game of Life -pelin logiikan sisäkkäisiä hajautustauluja käyttäen. Tarkastellaan nyt samaa kaksiulotteisten taulukkojen avulla.
  </p>
  
  <p>
    <a href="https://en.wikipedia.org/wiki/Conway's_Game_of_Life" target="_blank">Game of Life</a> on neljää yksinkertaista sääntöä seuraava soluautomaatti:
  </p>

  <ol>
    <li>Jos elävän solun naapureina on alle kaksi elävää solua, se kuolee alikansoituksen takia.</li>
    <li>Jos elävän solun naapureina on kaksi tai kolme elävää solua, se jää henkiin.</li>
    <li>Jos elävän solun naapureina on yli kolme elävää solua, se kuolee ylikansoituksen takia.</li>
    <li>Jos kuolleen solun naapureina on tasan kolme elävää solua, se syntyy eli muuttuu eläväksi.</li>
  </ol>

  <p>
    Peli ei sisällä minkäänlaisia liikkumissääntöjä, mutta se silti luo tilanteita, missä erilaiset hahmot liikkuvat ruudulla. Katso pelin keksineen <a href="https://youtu.be/E8kUJL04ELA" target="_blank">John Conwayn mietteitä pelistä sekä sääntöjen selitys</a>.
  </p>

  <p>
    Tässä tehtävässä toteutetaan oleellisilta osin Game of Life-pelin säännöt. Toteutusta varten tehtäväpohjassa on luokka GameOfLife, joka sisältää kaksiulotteisen taulukon, sekä luokka GameOfLifeSovellus, jota voidaan käyttää pelin visualisointiin.
  </p>

  <h2>Elossa olevien naapurien lukumäärä</h2>

  <p>
    Täydennä luokassa GameOfLife olevaa metodia <code>public int elossaOleviaNaapureita(int[][] taulukko, int x, int y)</code> siten, että se laskee annetun x, y -koordinaatin elossa olevien naapureiden lukumäärän. Naapuri on elossa jos sen arvo on 1.
  </p>

  <p>
    Naapureita ovat kaikki ne alkiot, jotka ovat kulman tai sivun kautta yhteydessä alkioon.
  </p>

  <p>
    Huomaa, että metodin tulee varoa ArrayIndexOutOfBounds-virhettä. Indeksissä -1 ei esimerkiksi voi olla ketään. Vastaavasti taulukon leveyden tai korkeuden yli ei voi mennä (esim. <code>taulukko[taulukko.length][0]</code> tai <code>taulukko[0][taulukko[0].length]</code>).
  </p>

  <p>
    Voit kokeilla metodiasi muunmuassa seuraavilla esimerkeillä.
  </p>

<pre class="sh_java code-highlight"><code>GameOfLife gol = new GameOfLife(3, 3);

int[][] taulukko = new int[3][3];
taulukko[0][0] = 1;
taulukko[0][1] = 1;
taulukko[1][1] = 1;
taulukko[2][2] = 1;

System.out.println(gol.elossaOleviaNaapureita(taulukko, 0, 0));
System.out.println(gol.elossaOleviaNaapureita(taulukko, 1, 0));
System.out.println(gol.elossaOleviaNaapureita(taulukko, 1, 1));
System.out.println(gol.elossaOleviaNaapureita(taulukko, 2, 2));
</code></pre>

<pre class="sample-output">2
3
3
1
</pre>

<pre class="sh_java code-highlight"><code>GameOfLife gol = new GameOfLife(4, 4);

int[][] taulukko = {{1, 1, 1, 1}, {1, 1, 1, 1}, {1, 0, 1, 0}, {0, 1, 0, 1}};

System.out.println(gol.elossaOleviaNaapureita(taulukko, 0, 0));
System.out.println(gol.elossaOleviaNaapureita(taulukko, 1, 1));
System.out.println(gol.elossaOleviaNaapureita(taulukko, 2, 2));
System.out.println(gol.elossaOleviaNaapureita(taulukko, 3, 3));
</code></pre>

<pre class="sample-output">3
7
5
1
</pre>


  <h2>Kehittyminen</h2>


  <p>
    Täydennä seuraavaksi GameOfLife-luokan metodia <code>public void kehity()</code> siten, että se käy yhden Game of Life -pelin askeleen.
  </p>

  <p>
    Toteuta toiminnallisuus niin, että luot toisen taulukon, jonka koko on sama kuin alkuperäisen taulukon. Käy tämän jälkeen alkuperäistä taulukkoa läpi alkio alkiolta siten, että seuraat seuraavia sääntöjä:
  </p>

  <ol>
    <li>Jos alkuperäisen taulukon alkion arvo on 1 ja sillä on alle kaksi elävää naapuria, kopioon asetetaan alkion arvoksi 0.</li>
    <li>Jos alkuperäisen taulukon alkion arvo on 1 ja sillä on kaksi tai kolme elävää naapuria, kopioon asetetaan alkion arvoksi 1.</li>
    <li>Jos alkuperäisen taulukon alkion arvo on 1 ja sillä on yli kolme elävää naapuria, kopioon asetetaan alkion arvoksi 0.</li>
    <li>Jos alkuperäisen taulukon alkion arvo on 0 ja sillä on tasan kolme elävää naapuria, kopioon asetetaan alkion arvoksi 1.</li>
  </ol>

  <p>
    Käytä naapureiden lukumäärän selvittämisessä edellisessä osassa tehtyä metodia. Kun olet käynyt koko taulukon läpi, vaihda kopio taulukon paikalle.
  </p>


  <p>
    Kokeile tämän jälkeen sovelluksen toimintaa graafisen käyttöliittymän kautta. Sovelluksen pitäisi käynnistyä -- yksi mahdollinen hetkellinen tila on seuraavanlainen.
  </p>

  <img src="../img/exercises/06-15-gameoflife-4ad85c50.png" width="600"/>
  


    </div>
  </div>
</div>


<h1 class="material-heading">
    Olio-ohjelmoinnin periaatteet

</h1>

<p>
  Olio-ohjelmointiin kuuluu oleellisesti kolme periaatetta: abstrahointi, kapselointi ja perintä. Käsittelemme periaatteet tässä lyhyesti; perintään tutustutaan tarkemmin ohjelmoinnin jatkokurssille.
</p>


<h3 class="material-heading">
    Abstrahointi

</h3>

<p>
  Abstrahoinnin tavoitteena on ongelma-alueen käsitteellistäminen. Ohjelmoija pyrkii nimeämään ongelma-alueen käsitteitä kuvaavat luokat, oliot, metodit ja muuttujat mahdollisimman hyvin, jolloin muut näitä käyttävät ohjelmoijat ymmärtävät mistä kussakin on kyse. 
</p>

<p>
  Käytännössä kyse on siis prosessista, missä ongelma-alueesta tunnistetaan ja eristetään oleellisimmat piirteet, joiden perusteella niistä luodaan ohjelmaan toiminnallisuutta. Samalla pyritään tilanteeseen, missä ongelma-alueesta on poimittu vain ne käsitteet, jotka ovat oleellisia käsiteltävän ongelman ratkaisun kannalta.
</p>

<p>
  <em>
    Otetaan analogia tosielämästä ja puhutaan käsitteestä auto. Jokainen tietää mistä autossa on kyse ja mihin sitä käytetään. Moni pystyisi myös piirtämään auton pyydettäessä. Käsite auto kuitenkin piilottaa paljon pienempiä osia: autossa on esimerkiksi renkaat, runko, moottori, istuimia, ... Kukin näistä käsitteistä on myös oma abstraktionsa. Esimerkiksi rengas piilottaa myös pienempiä osia -- renkaalla on vanne, ulkokumi, sisäkumi, jnejne.
  </em>
</p>

<p>
  Abstrahoinnista on ohjelmoijalle useita etuja. Se helpottaa asioista puhumista ja sitä kautta niiden käsittelyä. Se helpottaa ohjelmointia -- esimerkiksi käyttämämme apukirjastot kuten Scanner ovat toisten tekemiä valmiita abstraktioita ohjelmointiin liittyvistä tyypillisistä ongelmista. Se myös helpottaa omaa ohjelmointiamme: aivan kuten auto koostuu useammasta pienemmästä osasta, voimme koostaa ohjelmamme useammasta abstraktiosta ja luoda tätä kautta uusia abstraktioita.
</p>


<h3 class="material-heading">
    Kapselointi

</h3>

<p>
  Kapseloinissa on kyse toteutuksen piilottamisesta julkisen rajapinnan taakse. Käytännössä olio-ohjelmoinissa kyse on muuttujien ja metodien konkreettisen toiminnallisuuden piilottamisesta olion "sisään". Olion käyttöön tarvittavat metodit (ml. konstruktorit) -- eli rajapinta -- ovat käyttäjän nähtävissä, mutta käyttäjä ei pääse käsiksi olion sisäiseen toteutukseen.
</p>

<p>
  Tällöin toiset oliot voivat kutsua olion metodeja ilman, että niiden tarvitsee tietää kutsuttavan olion sisäisestä tilasta tai metodien konkreettisesta toteutuksesta. Tällöin kukin olio on myös itsenäinen, eikä niiden sisäinen tila ole riippuvainen toisten olioiden sisäisestä tilasta.
</p>


<h3 class="material-heading">
    Perintä

</h3>

<p>
  Olio-ohjelmoinnissa on mahdollista luoda luokkia, jotka perivät toisen luokan ominaisuuksia (eli oliomuuttujat ja metodit). Tällöin luokasta tehdyt oliot ovat samalla myös perityn luokan ilmentymiä, jolloin oliot voivat esiintyä useampina erilaisina olioina käyttötarpeesta riippuen.
</p>

<p>
  <em>
    Palaamme perintään ohjelmoinnin jatkokurssilla...
  </em>
</p>


<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Maatilasimulaattori (5 osaa)</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Maatiloilla on lypsäviä eläimiä, jotka tuottavat maitoa.  Maatilat eivät itse käsittele maitoa, vaan se kuljetetaan Maitoautoilla meijereille.  Meijerit ovat yleisiä maitotuotteita tuottavia rakennuksia.  Jokainen meijeri erikoistuu yhteen tuotetyyppiin, esimerkiksi Juustomeijeri tuottaa Juustoa, Voimeijeri tuottaa voita ja Maitomeijeri tuottaa maitoa.
  </p>

  <p>
    Rakennetaan maidon elämää kuvaava simulaattori.
  </p>


  <h2>Maitosäiliö</h2>

  <p>
    Jotta maito pysyisi tuoreena, täytyy se säilöä sille tarkoitettuun säiliöön. Säiliöitä valmistetaan sekä oletustilavuudella 2000 litraa, että asiakkaalle räätälöidyllä tilavuudella.  Toteuta luokka Maitosailio jolla on seuraavat konstruktorit ja metodit.
  </p>

  <ul>
    <li><strong>public Maitosailio()</strong></li>
    <li><strong>public Maitosailio(double tilavuus)</strong></li>
    <li><strong>public double getTilavuus()</strong></li>
    <li><strong>public double getSaldo()</strong></li>
    <li><strong>public double paljonkoTilaaJaljella()</strong></li>
    <li><strong>public void lisaaSailioon(double maara)</strong>
      lisää säiliöön vain niin paljon maitoa kuin sinne mahtuu,
      ylimääräiset jäävät lisäämättä, maitosäiliön ei siis tarvitse huolehtia tilanteesta jossa maitoa valuu yli</li>
    <li><strong>public double otaSailiosta(double maara)</strong>
      ottaa säiliöstä pyydetyn määrän, tai niin paljon kuin siellä on jäljellä
    </li>
  </ul>

  <p>
    Huomaa, että teet <em>kaksi konstruktoria</em>. Kutsuttava konstruktori määräytyy sille annettujen parametrien perusteella. Jos kutsut <code>new Maitosailio()</code>, suoritetaan ensimmäisen konstruktorin lähdekoodi. Toista konstruktoria taas kutsutaan antamalla konstruktorille parametrina tilavuus, esim. <code>new Maitosailio(300.0)</code>.
  </p>

  <p>
    Toteuta <code>Maitosailio</code>-luokalle myös <code>toString()</code>-metodi, jolla kuvaat sen tilaa. Ilmaistessasi säiliön tilaa <code>toString()</code>-metodissa, pyöristä litramäärät ylöspäin käyttäen <code>Math</code>-luokan tarjoamaa <code>ceil()</code>-metodia.
  </p>

  <p>
    Testaa maitosailiötä seuraavalla ohjelmapätkällä:
  </p>

<pre class="sh_java code-highlight"><code>Maitosailio sailio = new Maitosailio();
sailio.otaSailiosta(100);
sailio.lisaaSailioon(25);
sailio.otaSailiosta(5);
System.out.println(sailio);

sailio = new Maitosailio(50);
sailio.lisaaSailioon(100);
System.out.println(sailio);
</code></pre>

<pre class="sample-output">20.0/2000.0
50.0/50.0
</pre>


  <h2>Lehmä</h2>

  <p>
    Saadaksemme maitoa tarvitsemme myös lehmiä. Lehmällä on nimi ja utareet. Utareiden tilavuus on satunnainen luku väliltä 15 ja 40, luokkaa <code>Random</code> voi käyttäää satunnaislukujen arpomiseen, esimerkiksi  <code>int luku = 15 + new Random().nextInt(26);</code>. Luokalla <code>Lehma</code> on seuraavat toiminnot:
  </p>

  <ul>
    <li><strong>public Lehma()</strong> luo uuden lehmän satunnaisesti valitulla nimellä</li>
    <li><strong>public Lehma(String nimi)</strong> luo uuden lehmän annetulla nimellä</li>
    <li><strong>public String getNimi()</strong> palauttaa lehmän nimen</li>
    <li><strong>public double getTilavuus()</strong> palauttaa utareiden tilavuuden</li>
    <li><strong>public double getMaara()</strong> palauttaa utareissa olevan maidon määrän</li>
    <li><strong>public String toString()</strong> palauttaa lehmää kuvaavan merkkijonon (ks. esimerkki alla)</li>
  </ul>

  <p>
    <code>Lehma</code> toteuttaa myös rajapinnat: <code>Lypsava</code>, joka kuvaa lypsämiskäyttäytymistä, ja <code>Eleleva</code>, joka kuvaa elelemiskäyttäytymistä.
  </p>

<pre class="sh_java code-highlight"><code>public interface Lypsava {
    public double lypsa();
}

public interface Eleleva {
    public void eleleTunti();
}
</code></pre>


  <p>
    Lehmää lypsettäessä sen koko maitovarasto tyhjennetään jatkokäsittelyä varten. Lehmän elellessä sen maitovarasto täyttyy hiljalleen. Suomessa maidontuotannossa käytetyt lehmät tuottavat keskimäärin noin 25-30 litraa maitoa päivässä. Simuloidaan tätä tuotantoa tuottamalla noin 0.7 - 2 litraa tunnissa.
  </p>

  <p>
    Simuloi tuotantoa tuottamalla noin 0.7 - 2 litraa tunnissa. Random-luokan metodista <code>nextDouble</code>, joka palauttaa satunnaisluvun 0 ja 1 välillä lienee tässä hyötyä.
  </p>

  <p>
    Lisäksi, jos lehmälle ei anneta nimeä, valitse sille nimi satunnaisesti seuraavasta taulukosta. Tässä on hyötyä Random-luokan metodista <code>nextInt</code>, jolle annetaan parametrina yläraja. Kannattaa tutustua Random-luokan toimintaan erikseen ennen kuin lisää sen osaksi tätä ohjelmaa.
  </p>

<pre class="sh_java code-highlight"><code>private static final String[] NIMIA = new String[]{
    "Anu", "Arpa", "Essi", "Heluna", "Hely",
    "Hento", "Hilke", "Hilsu", "Hymy", "Matti", "Ilme", "Ilo",
    "Jaana", "Jami", "Jatta", "Laku", "Liekki",
    "Mainikki", "Mella", "Mimmi", "Naatti",
    "Nina", "Nyytti", "Papu", "Pullukka", "Pulu",
    "Rima", "Soma", "Sylkki", "Valpu", "Virpi"};
</code></pre>

  <p>
    Toteuta luokka Lehma ja testaa sen toimintaa seuraavan ohjelmapätkän avulla.
  </p>

<pre class="sh_java code-highlight"><code>Lehma lehma = new Lehma();
System.out.println(lehma);


Eleleva elelevaLehma = lehma;
elelevaLehma.eleleTunti();
elelevaLehma.eleleTunti();
elelevaLehma.eleleTunti();
elelevaLehma.eleleTunti();

System.out.println(lehma);

Lypsava lypsavaLehma = lehma;
lypsavaLehma.lypsa();

System.out.println(lehma);
System.out.println("");

lehma = new Lehma("Ammu");
System.out.println(lehma);
lehma.eleleTunti();
lehma.eleleTunti();
System.out.println(lehma);
lehma.lypsa();
System.out.println(lehma);
</code></pre>

  <p>
    Ohjelman tulostus on erimerkiksi seuraavanlainen.
  </p>

<pre class="sample-output">Liekki 0.0/23.0
Liekki 7.0/23.0
Liekki 0.0/23.0
Ammu 0.0/35.0
Ammu 9.0/35.0
Ammu 0.0/35.0
</pre>


  <h2>Lypsyrobotti</h2>

  <p>
    Nykyaikaisilla maatiloilla lypsyrobotit hoitavat lypsämisen. Jotta lypsyrobotti voi lypsää lypsävää otusta, tulee lypsyrobotin olla kiinnitetty maitosäiliöön:
  </p>

  <ul>
    <li><strong>public Lypsyrobotti()</strong> luo uuden lypsyrobotin</li>
    <li><strong>public Maitosailio getMaitosailio()</strong> palauttaa kiinnitetyn maitosäiliö tai <code>null</code>-viitteen, jos säiliötä ei ole vielä kiinnitetty</li>
    <li><strong>public void setMaitosailio(Maitosailio maitosailio)</strong> kiinnittää annetun säiliön lypsyrobottiin</li>
    <li><strong>public void lypsa(Lypsava lypsava)</strong> lypsää lehmän robottiin kiinnitettyyn maitosäiliöön. Jos robottiin ei ole kiinnitetty maitosäiliötä, ohjelma ilmoittaa että maito menee hukkaan.</li>
  </ul>

  <p>
    Toteuta luokka Lypsyrobotti ja testaa sitä seuraavien ohjelmanpätkien avulla. Varmista että lypsyrobotti voi lypsää kaikkia Lypsava-rajapinnan toteuttavia olioita!
  </p>

<pre class="sh_java code-highlight"><code>Lypsyrobotti lypsyrobotti = new Lypsyrobotti();
Lehma lehma = new Lehma();
lypsyrobotti.lypsa(lehma);
</code></pre>

<pre class="sample-output">Maidot menevät hukkaan!
</pre>

<pre class="sh_java code-highlight"><code>Lypsyrobotti lypsyrobotti = new Lypsyrobotti();
Lehma lehma = new Lehma();
System.out.println("");

Maitosailio sailio = new Maitosailio();
lypsyrobotti.setMaitosailio(sailio);
System.out.println("Säiliö: " + sailio);

for (int i = 0; i &lt; 2; i++) {
    System.out.println(lehma);
    System.out.println("Elellään..");
    for (int j = 0; j &lt; 5; j++) {
        lehma.eleleTunti();
    }
    System.out.println(lehma);

    System.out.println("Lypsetään...");
    lypsyrobotti.lypsa(lehma);
    System.out.println("Säiliö: " + sailio);
    System.out.println("");
}</code></pre>


  <p>
    Ohjelman tulostus on esimerkiksi seuraavanlainen.
  </p>

<pre class="sample-output">Säiliö: 0.0/2000.0
Mella 0.0/23.0
Elellään..
Mella 6.2/23.0
Lypsetään...
Säiliö: 6.2/2000.0

Mella 0.0/23.0
Elellään..
Mella 7.8/23.0
Lypsetään...
Säiliö: 14.0/2000.0
</pre>


  <h2>Navetta</h2>

  <p>
    Lehmät hoidetaan (eli tässä tapauksessa lypsetään) navetassa. Alkukantaisissa navetoissa on maitosäiliö ja tilaa yhdelle lypsyrobotille. Huomaa että lypsyrobottia asennettaessa se kytketään juuri kyseisen navetan maitosäiliöön.  Jos navetassa ei ole lypsyrobottia, ei siellä voida myöskään hoitaa lehmiä. Toteuta luokka <code>Navetta</code> jolla on seuraavat konstruktorit ja metodit:
  </p>

  <ul>
    <li><strong>public Navetta(Maitosailio maitosailio)</strong></li>
    <li><strong>public Maitosailio getMaitosailio()</strong> palauttaa navetan maitosailion</li>
    <li><strong>public void asennaLypsyrobotti(Lypsyrobotti lypsyrobotti)</strong> asentaa lypsyrobotin ja kiinnittää sen navetan maitosäiliöön</li>
    <li><strong>public void hoida(Lehma lehma)</strong> lypsää parametrina annetun lehmän lypsyrobotin avulla, metodi heittää poikkeuksen <code>IllegalStateException</code>, jos lypsyrobottia ei ole asennettu</li>
    <li><strong>public void hoida(Collection&lt;Lehma&gt; lehmat)</strong> lypsää parametrina annetut lehmät lypsyrobotin avulla, metodi heittää poikkeuksen <code>IllegalStateException</code>, jos lypsyrobottia ei ole asennettu</li>
    <li><strong>public String toString()</strong> palauttaa navetan sisältämän maitosäiliön tilan</li>
  </ul>

  <p>
    Testaa luokkaa <code>Navetta</code> seuraavan ohjelmapätkän avulla.
  </p>

<pre class="sh_java code-highlight"><code>Navetta navetta = new Navetta(new Maitosailio());
System.out.println("Navetta: " + navetta);

Lypsyrobotti robo = new Lypsyrobotti();
navetta.asennaLypsyrobotti(robo);

Lehma ammu = new Lehma();
ammu.eleleTunti();
ammu.eleleTunti();

navetta.hoida(ammu);
System.out.println("Navetta: " + navetta);

List&lt;Lehma&gt; lehmaLista = new ArrayList&lt;&gt;();
lehmaLista.add(ammu);
lehmaLista.add(new Lehma());

for (Lehma lehma: lehmaLista) {
    lehma.eleleTunti();
    lehma.eleleTunti();
};

navetta.hoida(lehmaLista);
System.out.println("Navetta: " + navetta);
</code></pre>

  <p>
    Tulostuksen tulee olla esimerkiksi seuraavanlainen:
  </p>

<pre class="sample-output">Navetta: 0.0/2000.0
Navetta: 2.8/2000.0
Navetta: 9.6/2000.0
</pre>


  <h2>Maatila</h2>

  <p>
    Maatilalla on omistaja ja siihen kuuluu navetta sekä joukko lehmiä. Maatila toteuttaa myös aiemmin nähdyn rajapinnan <code>Eleleva</code>, jonka metodia <code>eleleTunti()</code>-kutsumalla kaikki maatilaan liittyvät lehmät elelevät tunnin.  Toteuta luokka maatila siten, että se toimii seuraavien esimerkkiohjelmien mukaisesti.
  </p>

<pre class="sh_java code-highlight"><code>Maitosailio sailio = new Maitosailio();
Navetta navetta = new Navetta(sailio);

Maatila maatila = new Maatila("Esko", navetta);
System.out.println(maatila);

System.out.println(maatila.getOmistaja() + " on ahkera mies!");
</code></pre>

  <p>
    Odotettu tulostus:
  </p>

<pre class="sample-output">Maatilan omistaja: Esko
Navetan maitosäiliö: 0.0/2000.0
Ei lehmiä.
Esko on ahkera mies!
</pre>

<pre class="sh_java code-highlight"><code>Maatila maatila = new Maatila("Esko", new Navetta(new Maitosailio()));
maatila.lisaaLehma(new Lehma());
maatila.lisaaLehma(new Lehma());
maatila.lisaaLehma(new Lehma());
System.out.println(maatila);
</code></pre>

  <p>
    Odotettu tulostus:
  </p>

<pre class="sample-output">Maatilan omistaja: Esko
Navetan maitosäiliö: 0.0/2000.0
Lehmät:
    Naatti 0.0/19.0
    Hilke 0.0/30.0
    Sylkki 0.0/29.0
</pre>

<pre class="sh_java code-highlight"><code>Maatila maatila = new Maatila("Esko", new Navetta(new Maitosailio()));

maatila.lisaaLehma(new Lehma());
maatila.lisaaLehma(new Lehma());
maatila.lisaaLehma(new Lehma());

maatila.eleleTunti();
maatila.eleleTunti();

System.out.println(maatila);
</code></pre>

  <p>
    Odotettu tulostus:
  </p>

<pre class="sample-output">Maatilan omistaja: Esko
Navetan maitosäiliö: 0.0/2000.0
Lehmät:
    Heluna 2.0/17.0
    Rima 3.0/32.0
    Ilo 3.0/25.0
</pre>

<pre class="sh_java code-highlight"><code>Maatila maatila = new Maatila("Esko", new Navetta(new Maitosailio()));
Lypsyrobotti robo = new Lypsyrobotti();
maatila.asennaNavettaanLypsyrobotti(robo);

maatila.lisaaLehma(new Lehma());
maatila.lisaaLehma(new Lehma());
maatila.lisaaLehma(new Lehma());

maatila.eleleTunti();
maatila.eleleTunti();

maatila.hoidaLehmat();

System.out.println(maatila);
</code></pre>

  <p>
    Odotettu tulostus:
  </p>

<pre class="sample-output">Maatilan omistaja: Esko
Navetan maitosäiliö: 18.0/2000.0
Lehmät:
    Hilke 0.0/30.0
    Sylkki 0.0/35.0
    Hento 0.0/34.0
</pre>

  <p>
    Edellä otettiin ensiaskeleet simulaattorin tekemiseen. Ohjelmaa voisi jatkaa vaikkapa lisäämällä maitoauton sekä luomalla useampia navettoja. Maitoautot voisivat kulkea tehtaalle, jossa tehtäisiin juustoa, jnejne..
  </p>



    </div>
  </div>
</div>




<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Autorekisterikeskus (3 osaa)</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    TODO: låinkki hashmap-kertaukseen
  </p>


  <h2>Rekisterinumeron equals ja hashCode</h2>

  <p>
    Eurooppalaiset rekisteritunnukset koostuvat kahdesta osasta: yksi tai kaksikirjaimisesta maatunnuksesta ja maakohtaisesti määrittyvästä rekisterinumerosta, joka taas koostuu numeroista ja merkeistä. Rekisterinumeroita esitetään seuraavanlaisen luokan avulla:
  </p>

<pre class="sh_java code-highlight"><code>public class Rekisterinumero {
    // tässä määre final tarkoittaa sitä, että arvoa ei voi muuttaa asetuksen jälkeen
    private final String rekNro;
    private final String maa;

    public Rekisterinumero(String rekNro, String maa) {
       this.rekNro = rekNro;
       this.maa = maa;
    }

    public String toString(){
        return maa+ " "+rekNro;
    }
}
</code></pre>

  <p>
    Rekisterinumeroja halutaan tallettaa esim. ArrayList:eille ja käyttää HashMap:in avaimina, eli kuten yllä mainittu, tulee niille toteuttaa metodit <code>equals</code> ja <code>hashCode</code>, muuten ne eivät toimi halutulla tavalla. Toteuta luokalle rekisterinumero metodit <code>equals</code> ja <code>hashCode</code>.
  </p>

  <p>Esimerkkiohjelma:</p>

<pre class="sh_java code-highlight"><code>public static void main(String[] args) {
    Rekisterinumero rek1 = new Rekisterinumero("FI", "ABC-123");
    Rekisterinumero rek2 = new Rekisterinumero("FI", "UXE-465");
    Rekisterinumero rek3 = new Rekisterinumero("D", "B WQ-431");

    ArrayList&lt;Rekisterinumero&gt; suomalaiset = new ArrayList&lt;&gt;();
    suomalaiset.add(rek1);
    suomalaiset.add(rek2);

    Rekisterinumero uusi = new Rekisterinumero("FI", "ABC-123");
    if (!suomalaiset.contains(uusi)) {
        suomalaiset.add(uusi);
    }
    System.out.println("suomalaiset: " + suomalaiset);
    // jos equals-metodia ei ole ylikirjoitettu, menee sama rekisterinumero toistamiseen listalle

    HashMap&lt;Rekisterinumero, String&gt; omistajat = new HashMap&lt;&gt;();
    omistajat.put(rek1, "Arto");
    omistajat.put(rek3, "Jürgen");

    System.out.println("omistajat:");
    System.out.println(omistajat.get(new Rekisterinumero("FI", "ABC-123")));
    System.out.println(omistajat.get(new Rekisterinumero("D", "B WQ-431")));
    // jos hashCode ei ole ylikirjoitettu, eivät omistajat löydy
}
</code></pre>

  <p>
    Jos equals ja hashCode on toteutettu oikein, tulostus on seuraavanlainen.
  </p>

<pre class="sample-output">suomalaiset: [FI ABC-123, FI UXE-465]
omistajat:
Arto
Jürgen
</pre>


  <h2>Omistaja rekisterinumeron perusteella</h2>

  <p>
    Toteuta luokka <code>Ajoneuvorekisteri</code> jolla on seuraavat metodit:
  </p>

  <ul>
    <li><code>public boolean lisaa(Rekisterinumero rekkari, String omistaja)</code> lisää parametrina olevaa rekisterinumeroa vastaavalle autolle parametrina olevan omistajan, metodi palauttaa true jos omistajaa ei ollut ennestään, jos rekisterinumeroa vastaavalla autolla oli jo omistaja, metodi palauttaa false ja ei tee mitään</li>

    <li><code>public String hae(Rekisterinumero rekkari)</code> palauttaa parametrina olevaa rekisterinumeroa vastaavan auton omistajan. Jos auto ei ole rekisterissä, palautetaan <code>null</code></li>

    <li><code>public boolean poista(Rekisterinumero rekkari)</code> poistaa parametrina olevaa rekisterinumeroa vastaavat tiedot, metodi palauttaa true jos tiedot poistetiin, ja false jos parametria vastaavia tietoja ei ollut rekisterissä</li>
  </ul>

  <p>
    <strong>Huom:</strong> Ajoneuvorekisterin täytyy tallettaa omistajatiedot <code>HashMap&lt;Rekisterinumero, String&gt; omistajat</code> -tyyppiseen oliomuuttujaan!
  </p>


  <h2>Ajoneuvorekisteri laajenee</h2>

  <p>
    Lisää Ajoneuvorekisteriin vielä seuraavat metodit:
  </p>

  <ul>

    <li>
      <code>public void tulostaRekisterinumerot()</code> tulostaa rekisterissä olevat rekisterinumerot.
    </li>
    
    <li>
      <code>public void tulostaOmistajat()</code> tulostaa rekisterissä olevien autojen omistajat. Kukin nimi tulee tulostaa vain kertaalleen vaikka omistajalla olisikin useampi auto.
    </li>
  </ul>



    </div>
  </div>
</div>


---



<div class="hint">
  <div class="hint__header">
    <i class="fa fa-info-circle hint__icon"></i>Miten toimikaan for (int i = 0; ...?
  </div>

  <div class="hint__body">
    
  <p>
    Yllä olevassa esimerkissä käytettiin for-toistolausetta alkioiden läpikäyntiin. Toistolausetta käytetään listojen läpikäyntiin indeksien perusteella -- saman voisi toteuttaa myös while-toistolauseella. 
  </p>

<pre class="sh_java code-highlight"><code>ArrayList&lt;String&gt; sivut = new ArrayList&lt;&gt;();
sivut.add("Pilko metodisi lyhyiksi luettaviksi kokonaisuuksiksi.");
sivut.add("Erota käyttöliittymälogiikka sovelluksen logiikasta.");
sivut.add("Ohjelmoi aina ensin pieni osa, jolla ratkaiset osan ongelmasta.");
sivut.add("Harjoittelu tekee mestarin. Keksi ja tee omia kokeiluja ja projekteja.");

Sahkokirja kirja = new Sahkokirja("Vinkkejä ohjelmointiin.", sivut);

int sivu = 0;
while (sivu &lt; kirja.sivuja()) {
    System.out.println(kirja.lue());
    sivu++;
}
</code></pre>

  <p>
    Saman voi kirjoittaa myös for-toistolauseella seuraavasti.
  </p>

<pre class="sh_java code-highlight"><code>ArrayList&lt;String&gt; sivut = new ArrayList&lt;&gt;();
sivut.add("Pilko metodisi lyhyiksi luettaviksi kokonaisuuksiksi.");
sivut.add("Erota käyttöliittymälogiikka sovelluksen logiikasta.");
sivut.add("Ohjelmoi aina ensin pieni osa, jolla ratkaiset osan ongelmasta.");
sivut.add("Harjoittelu tekee mestarin. Keksi ja tee omia kokeiluja ja projekteja.");

Sahkokirja kirja = new Sahkokirja("Vinkkejä ohjelmointiin.", sivut);
for (int sivu = 0; sivu &lt; kirja.sivuja(); sivu++) {
    System.out.println(kirja.lue());
}
</code></pre>

  
  

  </div>
</div>


<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Sukunimet Espanjassa (2 osaa)</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Espanjassa ihmisillä on kaksi sukunimeä. Ennen vuoden 1999 lakimuutosta lapsen ensimmäinen sukunimi tuli isän ensimmäisestä sukunimestä ja toinen äidin ensimmäisestä sukunimestä. Vuonna 1999 lainsäädäntöä muutettiin niin, että vanhempien yhteisestä päätöksestä ensimmäiseksi sukunimeksi voidaan valita myös äidin ensimmäinen sukunimi.
  </p>

  <p>
    Tee tämän tehtävän luokat pakkaukseen <code>sukunimet</code>.
  </p>

  <h2>Henkilo</h2>
  
  <p>
    Tarkastellaan olioiden monimuotoisuutta luomalla vuotta 1999 edeltävää Espanjalaista nimentää kuvaava luokka Henkilo. 
  </p>

  <p>
    Luo luokka Henkilo, jolla on kaksi konstruktoria:
  </p>

  <ul>
    <li>
      public Henkilo(String etunimi, String ensimmainenSukunimi, String toinenSukunimi)
    </li>
    <li>
      public Henkilo(String etunimi, Henkilo isa, Henkilo aiti)
    </li>
  </ul>

  <p>
    Luo luokalle lisäksi toString-metodi, joka tulostaa henkilöä kuvaavan merkkijonoesityksen.
  </p>

  <p>
    Luokan tulee toimia seuraavasti. Huomaa myös viimeinen rivi, missä luokasta tehtyä oliota käsitellään Object-tyyppisenä. 
  </p>

<pre class="sh_java code-highlight"><code>Henkilo dolores = new Henkilo("Dolores", "D.", "Parto");
System.out.println(dolores);

Henkilo hay = new Henkilo("Hay", "Alen", "Gualarga");
System.out.println(hay);

Henkilo nacho = new Henkilo("Nacho", "Cuesta", "Parto");
System.out.println(nacho);

Henkilo valeria = new Henkilo("Valeria", "Mogollon", "Gualarga");
System.out.println(valeria);

Henkilo enrico = new Henkilo("Enrico", dolores, hay);
System.out.println(enrico);

Henkilo luz = new Henkilo("Luz", nacho, valeria);
System.out.println(luz);

Henkilo valentina = new Henkilo("Valentina", enrico, luz);
System.out.println(valentina);

Object valObject = valentina;
System.out.println(valObject);
</code></pre>


<pre class="sample-output">Dolores D. Parto
Hay Alen Gualarga
Nacho Cuesta Parto
Valeria Mogollon Gualarga
Enrico D. Alen
Luz Cuesta Mogollon
Valentina D. Cuesta
Valentina D. Cuesta
</pre>

  
  <h2>Perhe</h2>

  <p>
    Toteuta tämän jälkeen luokka <code>Perhe</code>. Luokan tulee toimia seuraavasti.
  </p>

  
<pre class="sh_java code-highlight"><code>Henkilo hay = new Henkilo("Hay", "Alen", "Gualarga");
Henkilo nacho = new Henkilo("Nacho", "Cuesta", "Parto");
Henkilo dolores = new Henkilo("Dolores", "D.", "Parto");
Henkilo enrico = new Henkilo("Enrico", dolores, hay);
Henkilo luz = new Henkilo("Luz", nacho, valeria);
Henkilo valentina = new Henkilo("Valentina", enrico, luz);

Perhe perhe = new Perhe();
perhe.lisaa(dolores);
perhe.lisaa(luz);
perhe.lisaa(valentina);
System.out.println(perhe);

System.out.println();

perhe.poista(luz);
System.out.println(perhe);

System.out.println();
    
Object perheObj = perhe;
System.out.println(perheObj);

System.out.println();
    
perhe.lisaa(enrico);
System.out.println(perheObj);
</code></pre>

<pre class="sample-output">Dolores D. Parto
Luz Cuesta Mogollon
Valentina D. Cuesta

Dolores D. Parto
Valentina D. Cuesta

Dolores D. Parto
Valentina D. Cuesta
Enrico D. Alen
</pre>

  <p>
    Tee sekä metodista <code>lisaa</code> että metodista <code>poista</code> sellaiset, että ne eivät palauta mitään arvoa. 
  </p>

  <p>
    Mikä tässä oikein oli monimuotoisuutta? Kaikki luokat ovat Object-tyyppisiä. Vaikka henkilöä tarkastellaan Object-oliona, suoritetaan <code>toString</code>-metodin lähdekoodi olion "oikeaan" tyyppiin liittyvästä luokasta.
  </p>
  



    </div>
  </div>
</div>



<h2 class="material-heading">
    Soluautomaatit

</h2>

<p>
  Tarkastellaan lyhyesti moniulotteisiin taulukoihin perustuvia <a href="https://fi.wikipedia.org/wiki/Soluautomaatti" target="_blank">soluautomaatteja</a>. Soluautomaatit ovat ohjelmallisesti rakennettuja simulaatioita, missä jokainen solu -- esimerkiksi moniulotteisen taulukon alkio -- kuvaa jonkinlaista tilaa maailmassa. Tilat muuttuvat simulaation aikana viereisten tilojen perusteella. 
</p>

<p>
  Soluautomaatit -- riippuen toki mallinnettavasta tilasta -- toteutetaan usein siten, että käytössä on useampi taulukko. Yksi taulukko näyttää tämän hetkistä tilannetta, ja seuraavaan taulukkoon lasketaan uusi tilanne. Tämä johtuu siitä, että mikäli yhtä taulukkoa käytettäisiin sekä nykyhetken ylläpitoon että uuden tilanteen laskemiseen, taulukko olisi välillä ns. välitilassa missä se sisältäisi sekä uuteen tilanteeseen liittyviä arvoja että aiemman hetken arvoja -- nämä voivat vaikuttaa laskentaan.
</p>

<p>
  Yksinkertainen esimerkki tilanteesta on seuraava soluautomaatti, missä solun arvoksi asetetaan 1 jos sillä on naapurina vähintään kaksi ykköstä, muulloin arvoksi tulee 0. 
</p>


<div class="pdf-slideshow-widget" data-pdf='../slideshows/soluautomaatti.pdf'></div>


<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Game of Life (2 osaa)</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Toteutimme aiemmin Game of Life -pelin logiikan sisäkkäisiä hajautustauluja käyttäen. Tarkastellaan nyt samaa kaksiulotteisten taulukkojen avulla.
  </p>
  
  <p>
    <a href="https://en.wikipedia.org/wiki/Conway's_Game_of_Life" target="_blank">Game of Life</a> on neljää yksinkertaista sääntöä seuraava soluautomaatti:
  </p>

  <ol>
    <li>Jos elävän solun naapureina on alle kaksi elävää solua, se kuolee alikansoituksen takia.</li>
    <li>Jos elävän solun naapureina on kaksi tai kolme elävää solua, se jää henkiin.</li>
    <li>Jos elävän solun naapureina on yli kolme elävää solua, se kuolee ylikansoituksen takia.</li>
    <li>Jos kuolleen solun naapureina on tasan kolme elävää solua, se syntyy eli muuttuu eläväksi.</li>
  </ol>

  <p>
    Peli ei sisällä minkäänlaisia liikkumissääntöjä, mutta se silti luo tilanteita, missä erilaiset hahmot liikkuvat ruudulla. Katso pelin keksineen <a href="https://youtu.be/E8kUJL04ELA" target="_blank">John Conwayn mietteitä pelistä sekä sääntöjen selitys</a>.
  </p>

  <p>
    Tässä tehtävässä toteutetaan oleellisilta osin Game of Life-pelin säännöt. Toteutusta varten tehtäväpohjassa on luokka GameOfLife, joka sisältää kaksiulotteisen taulukon, sekä luokka GameOfLifeSovellus, jota voidaan käyttää pelin visualisointiin.
  </p>

  <h2>Elossa olevien naapurien lukumäärä</h2>

  <p>
    Täydennä luokassa GameOfLife olevaa metodia <code>public int elossaOleviaNaapureita(int[][] taulukko, int x, int y)</code> siten, että se laskee annetun x, y -koordinaatin elossa olevien naapureiden lukumäärän. Naapuri on elossa jos sen arvo on 1.
  </p>

  <p>
    Naapureita ovat kaikki ne alkiot, jotka ovat kulman tai sivun kautta yhteydessä alkioon.
  </p>

  <p>
    Huomaa, että metodin tulee varoa ArrayIndexOutOfBounds-virhettä. Indeksissä -1 ei esimerkiksi voi olla ketään. Vastaavasti taulukon leveyden tai korkeuden yli ei voi mennä (esim. <code>taulukko[taulukko.length][0]</code> tai <code>taulukko[0][taulukko[0].length]</code>).
  </p>

  <p>
    Voit kokeilla metodiasi muunmuassa seuraavilla esimerkeillä.
  </p>

<pre class="sh_java code-highlight"><code>GameOfLife gol = new GameOfLife(3, 3);

int[][] taulukko = new int[3][3];
taulukko[0][0] = 1;
taulukko[0][1] = 1;
taulukko[1][1] = 1;
taulukko[2][2] = 1;

System.out.println(gol.elossaOleviaNaapureita(taulukko, 0, 0));
System.out.println(gol.elossaOleviaNaapureita(taulukko, 1, 0));
System.out.println(gol.elossaOleviaNaapureita(taulukko, 1, 1));
System.out.println(gol.elossaOleviaNaapureita(taulukko, 2, 2));
</code></pre>

<pre class="sample-output">2
3
3
1
</pre>

<pre class="sh_java code-highlight"><code>GameOfLife gol = new GameOfLife(4, 4);

int[][] taulukko = {{1, 1, 1, 1}, {1, 1, 1, 1}, {1, 0, 1, 0}, {0, 1, 0, 1}};

System.out.println(gol.elossaOleviaNaapureita(taulukko, 0, 0));
System.out.println(gol.elossaOleviaNaapureita(taulukko, 1, 1));
System.out.println(gol.elossaOleviaNaapureita(taulukko, 2, 2));
System.out.println(gol.elossaOleviaNaapureita(taulukko, 3, 3));
</code></pre>

<pre class="sample-output">3
7
5
1
</pre>


  <h2>Kehittyminen</h2>


  <p>
    Täydennä seuraavaksi GameOfLife-luokan metodia <code>public void kehity()</code> siten, että se käy yhden Game of Life -pelin askeleen.
  </p>

  <p>
    Toteuta toiminnallisuus niin, että luot toisen taulukon, jonka koko on sama kuin alkuperäisen taulukon. Käy tämän jälkeen alkuperäistä taulukkoa läpi alkio alkiolta siten, että seuraat seuraavia sääntöjä:
  </p>

  <ol>
    <li>Jos alkuperäisen taulukon alkion arvo on 1 ja sillä on alle kaksi elävää naapuria, kopioon asetetaan alkion arvoksi 0.</li>
    <li>Jos alkuperäisen taulukon alkion arvo on 1 ja sillä on kaksi tai kolme elävää naapuria, kopioon asetetaan alkion arvoksi 1.</li>
    <li>Jos alkuperäisen taulukon alkion arvo on 1 ja sillä on yli kolme elävää naapuria, kopioon asetetaan alkion arvoksi 0.</li>
    <li>Jos alkuperäisen taulukon alkion arvo on 0 ja sillä on tasan kolme elävää naapuria, kopioon asetetaan alkion arvoksi 1.</li>
  </ol>

  <p>
    Käytä naapureiden lukumäärän selvittämisessä edellisessä osassa tehtyä metodia. Kun olet käynyt koko taulukon läpi, vaihda kopio taulukon paikalle.
  </p>


  <p>
    Kokeile tämän jälkeen sovelluksen toimintaa graafisen käyttöliittymän kautta. Sovelluksen pitäisi käynnistyä -- yksi mahdollinen hetkellinen tila on seuraavanlainen.
  </p>

  <img src="../img/exercises/06-15-gameoflife-4ad85c50.png" width="600"/>
  


    </div>
  </div>
</div>

http://nifty.stanford.edu/2007/shiflet-fire/

        </div>
      </div>

      <div class="footer-wrapper">
        <footer class="footer">
  <div>
    Tämä materiaali on lisensoitu Creative Commons BY-NC-SA-lisenssillä
  </div>
  <div>
    Kurssin on tehnyt Helsingin Yliopiston Agile Education Research -tutkimusryhmä.
  </div>
    <div class="improvement">
<a href="../report_issue/" target="_blank" rel="noopener" class="btn btn-primary">    <i class="fa fa-exclamation-triangle" aria-hidden="true"></i>
    Ilmoita virhe
</a><a href="../edit_page/?path=jemma.html" target="_blank" rel="noopener" class="btn btn-primary">    <i class="fa fa-pencil-alt" aria-hidden="true"></i>
    Muokkaa sivua
</a>  <a href="https://github.com/materiaalit/ohjelmointi-s18" class="footer__github-link" target="_blank" rel="noopener">
    <i class="fab fa-github"></i>
  </a>
</div>

  </div>
</footer>

      </div>
    </div>

    <div class="modal fade" id="tmc-login-modal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content">
      <form id="tmc-login-form">
        <div class="modal-header">
          <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
          <h4 class="modal-title">Kirjaudu mooc.fi -käyttäjällesi</h4>
        </div>
        <div class="modal-body">
          <div class="alert alert-info">
            Puuttuuko sinulta mooc.fi -käyttäjätunnus? <a href="https://tmc.mooc.fi/user/new" class="alert-link" target="_blank" rel="noopener">Rekisteröidy</a>
          </div>

          <div class="alert alert-danger" id="tmc-login-error" style="display: none;"></div>

          <div class="form-group">
            <label>Käyttäjätunnus tai sähköpostiosoite</label>
            <input type="text" id="tmc-login-username" class="form-control" placeholder="Käyttäjätunnus tai sähköpostiosoite"/>
          </div>

          <div class="form-group">
            <label>Salasana</label>
            <input type="password" id="tmc-login-password" class="form-control" placeholder="Salasana"/>
          </div>

          <div class="form-group">
            <label>Kurssi</label>

            <div class="form-check">
              <label class="form-check-label">
                <input type="radio" class="form-check-input" name="tmcLoginCourse" value="hy-ohpe-s18">
                Ohjelmoinnin perusteet, syksy 2018 (Helsingin yliopisto)
              </label>
            </div>

            <div class="form-check">
              <label class="form-check-label">
                <input type="radio" class="form-check-input" name="tmcLoginCourse" value="hy-ohja-s18">
                Ohjelmoinnin jatkokurssi, syksy 2018 (Helsingin yliopisto)
              </label>
            </div>

          </div>
        </div>
        <div class="modal-footer">
          <a class="btn btn-secondary" data-dismiss="modal">Sulje</a>
          <button type="submit" class="btn btn-primary">Kirjaudu sisään</button>
        </div>
      </form>
    </div>
  </div>
</div>


    <div class="table-of-contents-layer" id="table-of-contents-layer">
</div>

<div class="table-of-contents" id="table-of-contents">
  <h1 class="table-of-contents__heading">
    Sisällysluettelo
  </h1>

  <div class="table-of-contents__content">
    <ul id="table-of-contents-list"></ul>
  </div>
</div>


    <script>
  window._QUIZNATOR_ENABLED = true;
</script>

<script src="https://quiznator.mooc.fi/javascripts/plugin-loader.min.js"></script>


    <script src="https://code.jquery.com/jquery-3.1.1.min.js"
	    integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
	    crossorigin="anonymous"></script>

    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

    <script src="../javascripts/scripts-77d48b13.js"></script>

    <script defer src="https://use.fontawesome.com/releases/v5.3.1/js/all.js" integrity="sha384-kW+oWsYx3YpxvjtZjFXqazFpA7UP/MbiY4jvs+RWZo2+N94PFZ36T6TFkc9O3qoB" crossorigin="anonymous"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>

    <script>hljs.initHighlightingOnLoad();</script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.1/cookieconsent.min.js"></script>
    <script src='//cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js'></script>

    <script>window.cookieconsent.initialise({"palette":{"popup":{"background":"#000"},"button":{"background":"#f1d600"}}, "position": "bottom-left"});</script>

    <script src='https://materiaalit.github.io/code-states-visualizer-cdn/app.js'></script>
    <script src='https://materiaalit.github.io/typonator-cdn/app.js'></script>
    <script src='https://crowdsorcerer.testmycode.io/dist/app.js'></script>
    <script src='https://materiaalit.github.io/pdf-slideshow-cdn/app.js'></script>
    <script>
      window.initPdfSlideshow('../pdf.worker.min-7be35925.js');
    </script>
  </body>
</html>
