<!DOCTYPE html>
<html>
  <head>
    <title>Ohjelmoinnin perusteet ja Ohjelmoinnin jatkokurssi, syksy 2018 | Osa 11</title>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">

    <link href="../stylesheets/styles-9fe27d3a.css" rel="stylesheet" />

    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/styles/xcode.min.css">

    <link rel="stylesheet" type="text/css" href="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.1/cookieconsent.min.css" />

    <link rel="stylesheet" href="https://materiaalit.github.io/code-states-visualizer-cdn/app.css" />
    <link rel="stylesheet" href="https://materiaalit.github.io/typonator-cdn/app.css" />
    <link rel="stylesheet" href="https://crowdsorcerer.testmycode.io/dist/app.css" />
    <link rel="stylesheet" href="https://materiaalit.github.io/pdf-slideshow-cdn/app.css" />

      <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-47575342-8', 'auto');
  ga('set', 'anonymizeIp', true);
  ga('send', 'pageview');
</script>

  </head>
  <body>
    <div class="main-wrapper">
      <div class="header-wrapper">
        <div class="browser-support-warning" id="browser-support-warning" style="display: none;">
  Kaikki tämän materiaalin osat eivät välttämättä tuo nykyistä selaintasi. Voisitko harkita vaihtamista <a href="https://www.google.com/chrome/browser/desktop/" target="_blank" rel="noopener">Chrome</a> tai <a href="https://www.mozilla.org/en-US/firefox/new/" target="_blank" rel="noopener">Firefox</a> selaimeen?
  <span class="browser-support-warning__close">Selvä!</span>
</div>


        <nav class="navbar navbar-light bg-white">
  <a class="navbar-brand" href="http://mooc.fi" alt="MOOC" target="_blank" rel="noopener">
    <span class="icon-mooc"></span>
  </a>

  <ul class="nav navbar-nav hidden-md-down">
      <li class="nav-item ">
        <a href="../" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=index.html&gt;')">Johdanto</a>
      </li>
      <li class="nav-item ">
        <a href="../part1/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part1.html&gt;')">Osa 1</a>
      </li>
      <li class="nav-item ">
        <a href="../part2/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part2.html&gt;')">Osa 2</a>
      </li>
      <li class="nav-item ">
        <a href="../part3/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part3.html&gt;')">Osa 3</a>
      </li>
      <li class="nav-item ">
        <a href="../part4/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part4.html&gt;')">Osa 4</a>
      </li>
      <li class="nav-item ">
        <a href="../part5/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part5.html&gt;')">Osa 5</a>
      </li>
      <li class="nav-item ">
        <a href="../part6/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part6.html&gt;')">Osa 6</a>
      </li>
      <li class="nav-item ">
        <a href="../part7/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part7.html&gt;')">Osa 7</a>
      </li>
      <li class="nav-item ">
        <a href="../part7-x/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part7-x.html&gt;')">Osa 7.X</a>
      </li>
      <li class="nav-item ">
        <a href="../part8/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part8.html&gt;')">Osa 8</a>
      </li>
      <li class="nav-item ">
        <a href="../part9/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part9.html&gt;')">Osa 9</a>
      </li>
      <li class="nav-item ">
        <a href="../part10/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part10.html&gt;')">Osa 10</a>
      </li>
      <li class="nav-item active">
        <a href="./" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part11.html&gt;')">Osa 11</a>
      </li>
      <li class="nav-item ">
        <a href="../part12/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part12.html&gt;')">Osa 12</a>
      </li>
      <li class="nav-item ">
        <a href="../part13/" class="nav-link" onclick="ga('send', 'event', 'navigation_topic_link', 'click', '#&lt;Middleman::Sitemap::Resource path=part13.html&gt;')">Osa 13</a>
      </li>
  </ul>

  <div class="float-xs-right navbar__buttons">
    <div class="dropdown" id="mobile-nav-dropdown">
      <button class="btn btn-secondary dropdown-toggle navbar__mobile-nav-toggle" data-toggle="dropdown">
        <i class="fa fa-bars"></i>
      </button>

      <div class="dropdown-menu">
      </div>
    </div>

    <a href="https://tmc.mooc.fi" target="_blank" rel="noopener" class="btn btn-secondary">
      <span class="hidden-md-down">Palautukset</span>
      <i class="fa fa-arrow-circle-up hidden-lg-up"></i>
    </a>

    <a href="https://t.me/ohjelmointi_s18" target="_blank" rel="noopener" class="btn btn-secondary">
      <span class="hidden-md-down">Chat</span>
      <i class="fa fa-comments hidden-lg-up"></i>
    </a>

    <button class="btn btn-secondary" id="table-of-contents-toggle">
      <span class="hidden-md-down">Sisällysluettelo</span>
      <i class="fa fa-ellipsis-h hidden-lg-up"></i>
    </button>

    <button class="btn btn-primary" id="tmc-login-toggle">Kirjaudu sisään</button>
  </div>
</nav>

      </div>

      <div class="content-wrapper">
        <div class="container material" id="material">
            <div class="exercise-list">
  <div class="exercise-list__header">
    Tehtävät
  </div>

  <div class="exercise-list__content" id="exercise-list"></div>

    <div class="exercise-list__quiznator">
      <div class="quiznator-dashboard"></div>

    </div>
</div>


          <div class="hint">
  <div class="hint__header">
    <i class="fa fa-info-circle hint__icon"></i>Yhdennentoista osan tavoitteet
  </div>

  <div class="hint__body">
    
  <p>
    Tiedät mitä geneeriset tyyppiparametrit ovat ja osaat luoda luokkia jotka käyttävät niitä. Tiedät pääpiirteittäin ArrayListin ja HashMapin sisäisen toteutuksen ja osaat luoda niistä yksinkertaistetut omat versiot. Tiedät miten satunnaislukuja luodaan ja osaat käyttää Javan valmiita välineitä satunnaislukujen luomiseen. Tunnet menetelmiä moniulotteisen tiedon esittämiseen ja osaat luoda sekä käsitellä moniulotteisia taulukoita.
  </p>


  </div>
</div>


<div class="quiznator-plugin" data-quiz-id="5a7e08e95b43a10004fb3879"></div>




<h1 class="material-heading">
    Geneeriset tyyppiparametrit

</h1>

<div class="learning-objectives">
  <div class="learning-objectives__header">
    <i class="fa fa-user-graduate learning-objectives__icon"></i>Oppimistavoitteet
  </div>

  <div class="learning-objectives__body">
    
  <ul>
    <li>
      Tiedät mitä käsitteellä geneerinen tyyppiparametri tarkoitetaan.
    </li>
    <li>
      Tunnet Javassa olevia geneerisiä tyyppiparametreja hyödyntäviä luokkia. 
    </li>
    <li>
      Osaat luoda omia luokkia, joissa käytetään geneerisiä tyyppiparametreja.
    </li>
  </ul>


  </div>
</div>


<p>
  Olemme listoihin tutustumisesta lähtien kertoneet tietorakenteille niiden sisältämän arvon tyypin. Esimerkiksi merkkijono-olioita sisältävä lista on esitelty muodossa <code>ArrayList&lt;String&gt;</code> ja merkkijonoja avaimina ja arvoina sisältävä hajautustaulu on esitelty muodossa <code>HashMap&lt;String, String&gt;</code>. Miten ihmeessä luokan voi toteuttaa niin, että luokka voi sisältää annetun tyyppisiä olioita?
</p>

<p>
  Geneerisyys (<em>generics</em>) liittyy olioita säilövien luokkien tapaan säilöä vapaavalintaisen tyyppisiä olioita. Vapaavalintaisuus perustuu luokkien määrittelyssä käytettyyn geneeriseen tyyppiparametriin, jonka avulla voidaan määritellä <em>olion luontivaiheessa</em> valittavia tyyppejä. Luokan geneerisyys määritellään antamalla luokan nimen jälkeen haluttu määrä luokan tyyppiparametreja luokan nimen jälkeen tulevien pienempi kuin ja suurempi kuin -merkkien väliin <code>public class Luokka&lt;Tyyppiparametri1, Tyyppiparametri2, ...&gt;</code>. Tyyppiparametrit määritellään tyypillisesti yhdellä kirjaimella.
</p>

<p>
  Toteutetaan oma geneerinen luokka <code>Lokero</code>, johon voi asettaa yhden minkälaisen tahansa olion.
</p>

<pre class="sh_java code-highlight"><code>public class Lokero&lt;T&gt; {
    private T alkio;

    public void asetaArvo(T alkio) {
        this.alkio = alkio;
    }

    public T haeArvo() {
        return alkio;
    }
}
</code></pre>

<p>
  Määrittely <code>public class Lokero&lt;T&gt;</code> kertoo että luokalle <code>Lokero</code> tulee antaa konstruktorissa tyyppiparametri. Konstruktorikutsun jälkeen kaikki olion sisäiset muuttujat tulevat olemaan kutsun yhteydessä annettua tyyppiä. Luodaan merkkijonon tallentava lokero.
</p>

<pre class="sh_java code-highlight"><code>Lokero&lt;String&gt; merkkijono = new Lokero&lt;&gt;();
merkkijono.asetaArvo(":)");

System.out.println(merkkijono.haeArvo());
</code></pre>

<pre class="sample-output">:)
</pre>

<p>
  Yllä olevalla ohjelmalla merkkijono-nimisen <code>Lokero</code>-olion <strong>ajonaikainen</strong> toteutus on seuraavanlainen.
</p>

<pre class="sh_java code-highlight"><code>public class Lokero&lt;String&gt; {
    private String alkio;

    public void asetaArvo(String alkio) {
        this.alkio = alkio;
    }

    public String haeArvo() {
        return alkio;
    }
}
</code></pre>

<p>
  Tyyppiparametria vaihtamalla voidaan luoda myös muuntyyppisiä olioita tallentavia <code>Lokero</code>-olioita. Esimerkiksi kokonaisluvun saa tallennettua seuraavasti.
</p>

<pre class="sh_java code-highlight"><code>Lokero&lt;Integer&gt; luku = new Lokero&lt;&gt;();
luku.asetaArvo(5);

System.out.println(luku.haeArvo());
</code></pre>

<pre class="sample-output">5
</pre>

<p>
  Vastaavasti esimerkiksi <code>Random</code>-olion sisältävän lokeron saa luotua seuraavalla tavalla. 
</p>

<pre class="sh_java code-highlight"><code>Lokero&lt;Random&gt; luku = new Lokero&lt;&gt;();
luku.asetaArvo(new Random());

System.out.println(luku.haeArvo().nextDouble());
</code></pre>

<p>
  Tyyppiparametrien määrää ei ole rajattu, vaan määrä riippuu toteutuksesta. Ohjelmoija voisi halutessaan toteuttaa esimerkiksi <code>Pari</code>-luokan, johon voi laittaa kaksi halutun tyyppistä oliota.
</p>

<pre class="sh_java code-highlight"><code>public class Pari&lt;T, K&gt; {
    private T eka;
    private K toka;

    public void asetaArvot(T eka, K toka) {
        this.eka = eka;
        this.toka = toka;
    }

    public T haeEka() {   
        return this.eka;
    }

    public K haeToka() {
        return this.toka;
    }
}
</code></pre>

<p>
  Huomattava osa Javan tietorakenteista käyttää tyyppiparametreja ja mahdollistaa eri tyyppisten muuttujien lisäämisen niihin. Esimerkiksi ArrayList saa yhden tyyppiparametrin, HashMap kaksi.
</p>

<pre class="sh_java code-highlight"><code>List&lt;String&gt; merkkijonot = new ArrayList&lt;&gt;();
Map&lt;String, String&gt; avainArvoParit = new HashMap&lt;&gt;();
</code></pre>

<p>
  Jatkossa kun näet esimerkiksi tyypin <code>ArrayList&lt;String&gt;</code> tiedät että sen sisäisessä rakenteessa on käytetty geneeristä tyyppiparametria. Sama periaate löytyy esimerkiksi rajapinnassa Comparable.
</p>



<p>
  Geneeristen rajapintojen tekeminen onnistuu samalla tavalla kuin geneeristen luokkien tekeminen. Alla on esimerkki geneerisestä rajapinnasta <code>Lista</code>.
</p>

<pre class="sh_java code-highlight"><code>public interface Lista&lt;T&gt; {
  void lisaa(T arvo);
  T hae(int indeksi);
  T poista(int indeksi); 
}
</code></pre>

<p> 
  Luokka voi toteuttaa geneerisen rajapinnan kahdella tavalla. Luokka voi määritellä rajapinnan toteutuksen yhteydessä rajapinnalle tyyppiparametrin tai luokalle voidaan myös määritellä tyyppiparametri. Alla olevassa esimerkissä on luokka <code>Elokuvalista</code>, joka määrittelee listan toteutuksen yhteydessä rajapinnalle tyyppiparametrin. Elokuvalista on vain elokuvien käsittelyyn tarkoitettu.
</p>

<pre class="sh_java code-highlight"><code>public class Elokuvalista implements Lista&lt;Elokuva&gt; {
    // oliomuuttujat

    @Override
    public void lisaa(Elokuva arvo) {
        // toteutus
    }

    @Override
    public Elokuva hae(int indeksi) {
        // toteutus
    }

    @Override
    public Elokuva poista(int indeksi) {
        // toteutus
    }
}
</code></pre>

<p>
  Toinen vaihtoehto on määritellä rajapinnan toteuttavalle luokalle tyyppiparametri, joka ohjataan myös rajapinnalle. Tällöin myös konkreettinen toteutus on geneerinen.
</p>

<pre class="sh_java code-highlight"><code>public class Yleislista&lt;T&gt; implements Lista&lt;T&gt; {
    // oliomuuttujat

    @Override
    public void lisaa(T arvo) {
        // toteutus
    }

    @Override
    public T hae(int indeksi) {
        // toteutus
    }

    @Override
    public T poista(int indeksi) {
        // toteutus
    }
}
</code></pre>

<p>
  Yleislistan voisi toteuttaa myös halutessaan esimerkiksi Javan valmiin ArrayList-luokan avulla. Tällöin toteutus olisi kutakuinkin seuraava.
</p>

<pre class="sh_java code-highlight"><code>import java.util.ArrayList;

public class Yleislista&lt;T&gt; implements Lista&lt;T&gt; {
    ArrayList&lt;T&gt; arvot;

    public Yleislista() {
        this.arvot = new ArrayList&lt;&gt;();
    }

    @Override
    public void lisaa(T arvo) {
        this.arvot.add(arvo);
    }

    @Override
    public T hae(int indeksi) {
        retun this.arvot.get(indeksi);
    }

    @Override
    public T poista(int indeksi) {
        T arvo = this.arvot.get(indeksi);
        this.arvot.remove(indeksi);
        return arvo;
    }
}
</code></pre>


<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Piilo</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Toteuta luokka Piilo, jolla on yksi geneerinen tyyppiparametri. Luokasta tehdyssä oliossa voi olla yksi olio kerralaan piilossa. Luokan tulee tarjota parametriton konstruktori sekä seuraavat kolme metodia:
  </p>

  <ul>
    <li>
      <code>public void laitaPiiloon(T piilotettava)</code> laittaa piiloon luokan tyyppiparametrin mukaisen olion. Mikäli piilossa on jo olio, vanha olio katoaa.
    </li>
    <li>
      <code>public T otaPiilosta()</code> ottaa piilosta luokan tyyppiparametrin mukaisen olion. Mikäli piilossa ei ole mitään, palautetaan <code>null</code>. Metodin kutsuminen palauttaa piilossa olevan olion ja poistaa olion piilosta.
    </li>
    <li>
      <code>public boolean onkoPiilossa()</code> palauttaa arvon <code>true</code> mikäli piilossa on olio. Mikäli piilossa ei ole oliota, palauttaa arvon <code>false</code>.
    </li>
  </ul>

  <p>
    <em>
      <strong>Luokalle ei ole tehtäväpohjassa testejä</strong>. Palauta tehtävä kun seuraavat esimerkit toimivat toivotulla tavalla.
    </em>
  </p>


<pre class="sh_java code-highlight"><code>Piilo&lt;String&gt; jemma = new Piilo&lt;&gt;();
System.out.println(jemma.onkoPiilossa());
jemma.laitaPiiloon("kukkuu");
System.out.println(jemma.onkoPiilossa());
System.out.println(jemma.otaPiilosta());
System.out.println(jemma.onkoPiilossa());
jemma.laitaPiiloon("kukkuluuruu");
jemma.laitaPiiloon("huhuu");
System.out.println(jemma.onkoPiilossa());
System.out.println(jemma.otaPiilosta());
System.out.println(jemma.onkoPiilossa());
</code></pre>

<pre class="sh_java code-highlight"><code>false
true
kukkuu
false
true
huhuu
false
</code></pre>

<pre class="sh_java code-highlight"><code>Piilo&lt;Integer&gt; jemma = new Piilo&lt;&gt;();
System.out.println(jemma.onkoPiilossa());
jemma.laitaPiiloon(1);
System.out.println(jemma.onkoPiilossa());
System.out.println(jemma.onkoPiilossa());
System.out.println(jemma.otaPiilosta());
System.out.println(jemma.onkoPiilossa());
</code></pre>

<pre class="sh_java code-highlight"><code>false
true
true
1
false
</code></pre>



        <hr/>

        Tehtävään on olemassa esimerkkiratkaisu <a href="https://tmc.mooc.fi/" target="_blank" rel="noopener">Test My Code</a> -järjestelmässä. Esimerkkiratkaisua voi käyttää oman oppimisen tukena, ja se on tarkasteltavissa jo ennen kuin olet saanut tehtävän valmiiksi. Esimerkkiratkaisuun pääset käsiksi <a href="https://tmc.mooc.fi/exercises/53838/solution" target="_blank" rel="noopener">täältä</a>. Huomaathan, että tehtävän voi ratkaista monella tapaa, ja tässä annettu esimerkkiratkaisu on näistä vain yksi.

    </div>
  </div>
</div>

<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Putki</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Toteuta luokka Putki, jolla on yksi geneerinen tyyppiparametri. Putki toimii siten, että sinne voi lisätä arvoja ja sieltä voi ottaa arvoja. Lisääminen tapahtuu putken toisesta päästä ja ottaminen toisesta päästä, eli toisin sanoen putkesta otetaan aina siellä pisimpään ollut arvo kun taas sinne lisätään aina uusin arvo. Luokan tulee tarjota parametriton konstruktori sekä seuraavat kolme metodia:
  </p>

  <ul>
    <li>
      <code>public void lisaaPutkeen(T arvo)</code> lisää putkeen luokan tyyppiparametrin mukaisen olion.
    </li>
    <li>
      <code>public T otaPutkesta()</code> ottaa putkesta siellä pisimpään olleen arvon. Mikäli putkessa ei ole mitään, palautetaan <code>null</code>. Metodin kutsuminen palauttaa putkessa pisimpään olleen olion ja poistaa sen putkesta.
    </li>
    <li>
      <code>public boolean onkoPutkessa()</code> palauttaa arvon <code>true</code> mikäli putkessa on arvoja. Mikäli putki on tyhjä, palauttaa arvon <code>false</code>.
    </li>
  </ul>

  <p>
    Tee luokan sisäinen toteutus ArrayListin avulla.
  </p>

  <p>
    <em>
      <strong>Luokalle ei ole tehtäväpohjassa testejä</strong>. Palauta tehtävä kun seuraavat esimerkit toimivat toivotulla tavalla.
    </em>
  </p>

<pre class="sh_java code-highlight"><code>Putki&lt;String&gt; putki = new Putki&lt;&gt;();
putki.lisaaPutkeen("dibi");
putki.lisaaPutkeen("dab");
putki.lisaaPutkeen("dab");
putki.lisaaPutkeen("daa");
while(putki.onkoPutkessa()) {
    System.out.println(putki.otaPutkesta());
}
</code></pre>

<pre class="sh_java code-highlight"><code>dibi
dab
dab
daa
</code></pre>

<pre class="sh_java code-highlight"><code>Putki&lt;Integer&gt; numeroputki = new Putki&lt;&gt;();
numeroputki.lisaaPutkeen(1);
numeroputki.lisaaPutkeen(2);
numeroputki.lisaaPutkeen(3);

int summa = 0;
while(numeroputki.onkoPutkessa()) {
    summa = summa + numeroputki.otaPutkesta();
}
System.out.println(summa);
System.out.println(numeroputki.otaPutkesta());
</code></pre>

<pre class="sh_java code-highlight"><code>6
null
</code></pre>



        <hr/>

        Tehtävään on olemassa esimerkkiratkaisu <a href="https://tmc.mooc.fi/" target="_blank" rel="noopener">Test My Code</a> -järjestelmässä. Esimerkkiratkaisua voi käyttää oman oppimisen tukena, ja se on tarkasteltavissa jo ennen kuin olet saanut tehtävän valmiiksi. Esimerkkiratkaisuun pääset käsiksi <a href="https://tmc.mooc.fi/exercises/53839/solution" target="_blank" rel="noopener">täältä</a>. Huomaathan, että tehtävän voi ratkaista monella tapaa, ja tässä annettu esimerkkiratkaisu on näistä vain yksi.

    </div>
  </div>
</div>


<h1 class="material-heading">
    ArrayList ja Hajautustaulu

</h1>

<div class="learning-objectives">
  <div class="learning-objectives__header">
    <i class="fa fa-user-graduate learning-objectives__icon"></i>Oppimistavoitteet
  </div>

  <div class="learning-objectives__body">
    
  <ul>
    <li>
      Tiedät miten miten muuttuvankokoinen geneerinen lista toteutetaan.  
    </li>
    <li>
      Tunnet erään mahdollisen tavan Javan ArrayListin kaltaisen luokan toteutukselle.
    </li>
    <li>
      Tiedät miten miten hajautustaulu toteutetaan.  
    </li>
    <li>
      Tunnet erään mahdollisen tavan Javan HashMapin kaltaisen luokan toteutukselle.
    </li>
  </ul>


  </div>
</div>


<p>
  ArrayList ja Hajautustaulu ovat ohjemoinnissa hyvin yleisesti käytettyjä tietorakenteita. Tarkastellaan tässä niiden todellista toteutusta. Kerrataan ensin lyhyesti taulukon käyttöä, jonka jälkeen rakennetaan esimerkinomaisesti ensin ArrayListiä imitoiva tietorakenne <code>Lista</code>, jota hyödynnetään sitten tietorakenteen <code>Hajautustaulu</code> tekemisessä.
</p>


<h2 class="material-heading">
    Lyhyt kertaus taulukoista

</h2>

<p>
  Taulukko on olio, joka sisältää rajatun määrän numeroituja paikkoja arvoille. Taulukon pituus (tai koko) on siinä olevien paikkojen lukumäärä, eli kuinka monta arvoa taulukkoon voi laittaa. Taulukon koko on aina ennalta määrätty: koko määrätään taulukon luomisen yhteydessä eikä sitä voi muuttaa.
</p>

<p>
  Taulukkotyyppi määritellään hakasuluilla, jota edeltää taulukossa olevien alkioiden tyyppi (alkioidentyyppi[]). Taulukko luodaan <code>new</code>-kutsulla, jota seuraa taulukon alkioiden tyyppi, hakasulut, sekä hakasulkujen sisään asetettava luotavan taulukon alkioiden lukumäärä.
</p>

<pre class="sh_java code-highlight"><code>int[] luvut = new int[3];
String[] merkkijonot = new String[5];
</code></pre>

<p>
  Taulukon alkioihin viitataan taulukon indeksien perusteella. Alla olevassa esimerkissä luodaan kolmepaikkainen kokonaislukutaulukko, jonka jälkeen taulukon indekseihin 0 ja 2 asetetaan arvot. Tämän jälkeen arvot tulostetaan.
</p>

<pre class="sh_java code-highlight"><code>int[] luvut = new int[3];
luvut[0] = 2;
luvut[2] = 5;

System.out.println(luvut[0]);
System.out.println(luvut[2]);
</code></pre>

<pre class="sample-output">2
5
</pre>

<p>
  Yksittäisen arvon asettaminen taulukon tiettyyn paikkaan tapahtuu kuten arvon asetus tavalliseen muuttujaan, mutta taulukkoon asetettaessa kerrotaan paikkaa kuvaava indeksi. 
</p>

<p>
  Taulukko-olion koon saa selville taulukko-olioon liittyvän julkisen oliomuuttujan <code>length</code> avulla, ja taulukon alkioiden läpikäynti voidaan toteuttaa esimerkiksi for-toistolauseen avulla.
</p>

<pre class="sh_java code-highlight"><code>int[] luvut = new int[4];
luvut[0] = 42;
luvut[1] = 13;
luvut[2] = 12;
luvut[3] = 7;

System.out.println("Taulukossa on " + luvut.length + " alkiota.");

for (int i = 0; i &lt; luvut.length; i++) {
    System.out.println(luvut[i]);
}
</code></pre>


<pre class="sample-output">Taulukossa on 4 alkiota.
42
13
12
7
</pre>

<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Rajatut taulukossa</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Luo luokkaan <code>Ohjelma</code> luokkametodi <code>public static int summa(int[] taulukko, int mista, int mihin, int pienin, int suurin)</code>. Metodin tulee laskea sille parametrina annetusta taulukosta indeksien mista ja mihin välillä olevien arvojen summa. Summaan otetaan mukaan vain ne arvot, jotka ovat suurempia tai yhtäsuuria kuin pienin ja pienempiä tai yhtä pieniä kuin suurin.
  </p>

  <p>
    Metodin tulee lisäksi varmistaa, että käsiteltävät indeksit ovat valideja. Mikäli parametri <code>mista</code> on pienempi kuin 0, tulee taulukon indeksien läpikäynti alkaa parametrin mista arvon sijaan nollasta. Vastaavasti, mikäli parametri <code>mihin</code> on suurempi kuin käsiteltävä taulukko, tulee taulukon indeksien läpikäynti lopettaa  parametrin mihin arvon sijaan taulukon kokoon. 
  </p>


<pre class="sh_java code-highlight"><code>int[] luvut = {3, -1, 8, 4};
    
System.out.println(summa(luvut, 0, 0, 0, 0)); 
System.out.println(summa(luvut, 0, 0, 0, 10)); 
System.out.println(summa(luvut, 0, 1, 0, 10)); 
System.out.println(summa(luvut, 0, 1, -10, 10)); 
System.out.println(summa(luvut, -1, 999, -10, 10)); 
</code></pre>


<pre class="sample-output">0
3
3
2
14
</pre>
  


        <hr/>

        Tehtävään on olemassa esimerkkiratkaisu <a href="https://tmc.mooc.fi/" target="_blank" rel="noopener">Test My Code</a> -järjestelmässä. Esimerkkiratkaisua voi käyttää oman oppimisen tukena, ja se on tarkasteltavissa jo ennen kuin olet saanut tehtävän valmiiksi. Esimerkkiratkaisuun pääset käsiksi <a href="https://tmc.mooc.fi/exercises/53840/solution" target="_blank" rel="noopener">täältä</a>. Huomaathan, että tehtävän voi ratkaista monella tapaa, ja tässä annettu esimerkkiratkaisu on näistä vain yksi.

    </div>
  </div>
</div>

<p>
  Taulukoita voi käyttää täysin samalla tavalla kuin muitakin muuttujia, eli niitä voi käyttää esimerkiksi oliomuuttujina, metodin parametreina, metodin paluuarvona ym. 
</p>

<p>
  Merkittävä osa yleisesti käytetyistä tietorakenteista käyttää taulukoita niiden sisäisessä toteutuksessa. 
</p>


<h2 class="material-heading">
    Listarakenne

</h2>

<p>
  Tarkastellaan erästä tapaa Javan tarjoaman ArrayList-tietorakenteen toteuttamiseen. Javan ArrayList hyödyntää sisäisesti taulukkoa, jonka alkioiden tyyppi on määritelty luokalle ArrayList annettavan tyyppiparametrin avulla. Tämän takia listalle saa lisätä käytännössä minkä tyyppisiä arvoja tahansa. Lista tarjoaa useita metodeja, joista tämän esimerkin kannalta oleellisia ovat <code>add</code> eli lisääminen, <code>contains</code> eli olemassaolon tarkastaminen, <code>remove</code> eli poistaminen sekä <code>get</code>, eli tietystä indeksistä hakeminen.
</p>

<pre class="sh_java code-highlight"><code>ArrayList&lt;String&gt; merkkijonot = new ArrayList&lt;&gt;();
System.out.println(merkkijonot.contains("Hei!"));
merkkijonot.add("Hei!");
System.out.println(merkkijonot.contains("Hei!"));
merkkijonot.remove("Hei!");
System.out.println(merkkijonot.contains("Hei!"));
</code></pre>

<pre class="sample-output">false
true
false
</pre>

<h3 class="material-heading">
    Listan luominen

</h3>

<p>
  Luodaan luokka <code>Lista</code>. Listarakenne sisältää geneerisen taulukon -- eli taulukon, jonka alkioiden tyyppi määräytyy ajonaikaisesti tyyppiparametreista. Asetetaan taulukon alkukooksi <code>10</code>. Taulukko luodaan object tyyppisenä ja muunnetaan geneerisen tyyppiseksi <code>(T[]) new Object[10];</code> -- tämä tehdään, sillä kutsu <code>new T[10];</code> ei ainakaan toistaiseksi toimi Javassa.
</p>

<pre class="sh_java code-highlight"><code>public class Lista&lt;T&gt; {
    private T[] arvot;

    public Lista() {
        this.arvot = (T[]) new Object[10];
    }
}
</code></pre>

<p>
  Lista kapseloi taulukon. Alkutilanteessa jokainen taulukon indeksi sisältää <code>null</code>-viitteen.
</p>

<h3 class="material-heading">
    Arvojen lisääminen listalle

</h3>

<p>
  Lisätään luokalle metodi <code>public void lisaa(T arvo)</code>, mikä mahdollistaa arvojen lisäämisen listalle. Luodaan luokalle tätä varten erillinen kokonaislukumuuttuja, joka pitää kirjaa taulukon ensimmäisestä tyhjästä paikasta.
</p>

<pre class="sh_java code-highlight"><code>public class Lista&lt;T&gt; {

    private T[] arvot;
    private int arvoja;

    public Lista() {
        this.arvot = (T[]) new Object[10];
        this.arvoja = 0;
    }

    public void lisaa(T arvo) {
        this.arvot[this.arvoja] = arvo;
        this.arvoja++; // sama kuin this.arvoja = this.arvoja + 1;
    }
}
</code></pre>

<p>
  Nyt arvojen lisääminen listalle onnistuu -- tai, ainakin listan luominen ja metodin kutsuminen onnistuu -- emme vielä voi testata ovatko arvot todellisuudessa listalla.
</p>

<pre class="sh_java code-highlight"><code>Lista&lt;String&gt; lista = new Lista&lt;&gt;();
lista.lisaa("hei");
lista.lisaa("maailma");
</code></pre>

<h3 class="material-heading">
    Arvojen lisääminen listalle, osa 2

</h3>

<p>
  Edellä kuvatussa <code>lisaa</code>-metodissa on pieni ongelma. Ongelma ilmenee kun seuraava ohjelmakoodi suoritetaan.
</p>

<pre class="sh_java code-highlight"><code>Lista&lt;String&gt; lista = new Lista&lt;&gt;();
for (int i = 0; i &lt; 11; i++) {
    lista.lisaa("hei");
}
</code></pre>

<pre class="sample-output">Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 10
at tietorakenteita.Lista.lisaa(Lista.java:14)
at tietorakenteita.Ohjelma.main(Ohjelma.java:8)
</pre>

<p>
  Listan koko ei kasva. Eräs ArrayList-luokan oleellisimmista toiminnallisuuksista on se, että sen koko kasvaa aina tarvittaessa -- ohjelmoijan ei siis tarvitse varoa listan täyttymistä.
</p>

<p>
  Lisätään ohjelmaan listan koon kasvattamiseen liittyvä toiminnallisuus. Listan kokoa kasvatetaan aina jos täyteen listaan (eli listan sisällä olevaan täyteen taulukkoon) yritetään lisätä arvo. Kasvattaminen toteutetaan luomalla uusi taulukko, johon vanhan taulukon arvot kopioidaan. Tämän jälkeen vanha taulukko jätetään heitteille, ja uudesta taulukosta tulee olion käyttämä taulukko.
</p>

<p>
  Uuden taulukon koko määräytyy Javassa kaavalla <code>vanhakoko + vanhaKoko / 2</code>. Hyödynnetään samaa kaavaa omassa toteutuksessamme. Luodaan kasvattamista varten erillinen metodi <code>kasvata</code>, joka on vain luokan omien metodien käytössä (eli sillä on <code>private</code>-näkyvyys).
</p>

<pre class="sh_java code-highlight"><code>private void kasvata() {
    int uusiKoko = this.arvot.length + this.arvot.length / 2;
    T[] uusi = (T[]) new Object[uusiKoko];
    for (int i = 0; i &lt; this.arvot.length; i++) {
        uusi[i] = this.arvot[i];
    }
  
    this.arvot = uusi;
}
</code></pre>

<p>
  Toteutus luo uuden taulukon, jonka koko on 1.5-kertainen vanhaan taulukkoon verrattuna. Tämän jälkeen kaikki vanhan taulukon alkiot kopioidaan uuteen taulukkoon ja lopulta olion <code>arvot</code>-muuttujan -- eli taulukon -- arvoksi asetetaan uusi taulukko. Javan automaattinen roskienkerääjä poistaa vanhan taulukon kun siihen ei enää viitata.
</p>

<p>
  Muokataan vielä metodia <code>lisaa</code> siten, että taulukon kokoa kasvatetaan tarvittaessa.
</p>

<pre class="sh_java code-highlight"><code>public void lisaa(T arvo) {
    if(this.arvoja == this.arvot.length) {
        kasvata();
    }
  
    this.arvot[this.arvoja] = arvo;
    this.arvoja++;
}
</code></pre>

<p>
  Nyt arvoja voi lisätä listalle lähes rajattomasti.
</p>


<div class="hint">
  <div class="hint__header">
    <i class="fa fa-info-circle hint__icon"></i>Edellä kuvatun kasvatusmenetelmän tehokkuudesta
  </div>

  <div class="hint__body">
    
  <p>
    Edellä kuvattu menetelmä kopioi kasvatuksen yhteydessä jokaisen vanhan taulukon arvon uuteen taulukkoon. Mikäli taulukossa on esimerkiksi kaksi miljoonaa alkiota, kopiointi käy kaksi miljoonaa alkiota läpi.
  </p>

  <p>
    Menetelmän tehokkuuteen -- ja parannusehdotuksiin -- paneudutaan muunmuassa kursseilla Tietorakenteet ja algoritmit sekä Algoritmien suunnittelu ja analyysi.
  </p>


  </div>
</div>


<h3 class="material-heading">
    Arvon olemassaolon tarkastaminen

</h3>

<p>
  Luodaan listalle seuraavaksi metodi <code>public boolean sisaltaa(T arvo)</code>, minkä avulla voidaan tarkistaa onko alkio listalla. Hyödynnetään tässä tietoa siitä, että jokainen Javan olio -- riippumatta sen tyypistä -- perii Object-luokan (tai on Object-tyyppinen). Tämän takia jokaisella oliolla on metodi <code>public boolean equals(Object object)</code>, jota voidaan käyttää yhtäsuuruuden tarkasteluun.
</p>

<p>
  Luokan <code>Lista</code> muuttuja <code>arvoja</code> sisältää tiedon arvojen tämän hetkisestä lukumäärästä. Voimme siis toteuttaa <code>sisaltaa</code>-metodin siten, että tarkastelemme vain ne listan indeksit, joissa on arvoja.
</p>

<pre class="sh_java code-highlight"><code>public boolean sisaltaa(T arvo) {
    for (int i = 0; i &lt; this.arvoja; i++) {
        if (this.arvot[i].equals(arvo)) {
            return true;
        }
    }
  
    return false;
}
</code></pre>

<p>
  Ohjelmassa on nyt mahdollisuus listalla olevien alkioiden olemassaolon tarkasteluun.
</p>

<pre class="sh_java code-highlight"><code>Lista&lt;String&gt; lista = new Lista&lt;&gt;();
System.out.println(lista.sisaltaa("hei"));
lista.lisaa("hei");
System.out.println(lista.sisaltaa("hei"));
</code></pre>


<pre class="sample-output">false
true
</pre>

<p>
  Edellä esitetty menetelmä olettaa, että käyttäjä ei lisää listalle <code>null</code>-viitettä ja että equals-metodi tarkastaa ettei parametrina saatu arvo ole null.
</p>


<h3 class="material-heading">
    Arvon poistaminen

</h3>

<p>
  Toteuttamallemme listalle voi nyt lisätä arvoja, jonka lisäksi arvon olemassaolon voi tarkastaa. Toteutetaan vielä arvon poistaminen. Toteutetaan metodi <code>public void poista(T arvo)</code>, joka poistaa listalta <em>yhden</em> <code>arvo</code>-arvoisen alkion.
</p>

<p>
  Yksinkertainen toteutus olisi seuraava.
</p>


<pre class="sh_java code-highlight"><code>public void poista(T arvo) {
    for (int i = 0; i &lt; this.arvoja; i++) {
        if (arvo == this.arvot[i] || this.arvot[i].equals(arvo)) {
            this.arvot[i] = null;
            this.arvoja--;
            return true;
        }
    }
  
    return false;
}
</code></pre>

<p>
  Yllä oleva lähestymistapa on kuitenkin ongelmallinen, sillä se jättää listalle "tyhjiä" kohtia, jonka lisäksi esimerkiksi edellä esitetty etsiminen ei enää.
</p>

<p>
  Ongelman voi ratkaista useammalla tavalla, joista yksi on siirtää jokaista poistettua arvoa seuraavaa arvoa vasemmalle. Lisätään tämä toiminnallisuus ohjelmaan.
</p>

<pre class="sh_java code-highlight"><code>public void poista(T arvo) {
    boolean loytyi = false;
    for (int i = 0; i &lt; this.arvoja; i++) {
        if (loytyi) {
            this.arvot[i - 1] = this.arvot[i];
        } else if (arvo == this.arvot[i] || this.arvot[i].equals(arvo)) {
            this.arvoja--;
            loytyi = true;
        }
    }
}
</code></pre>

<p>
  Emme ole kovin tyytyväisiä edelliseen ratkaisuun, sillä siinä tehdään monta asiaa samaan aikaan. Metodissa sekä etsitään alkiota että siirretään alkioita. Pilkotaan toiminnallisuus kahteen erilliseen metodiin: <code>private int arvonIndeksi(T arvo)</code>, joka etsii parametrina annetun arvon indeksin, sekä <code>private void siirraVasemmalle(int indeksista)</code>, joka siirtää annetusta indeksistä lähtien alkioita yhden vasemmalle.
</p>

<p>
  Toteutetaan ensin metodi <code>private int arvonIndeksi(T arvo)</code>, joka etsii annetun arvon indeksin. Metodi palauttaa negatiivisen luvun mikäli arvoa ei löydy.
</p>

<pre class="sh_java code-highlight"><code>private int arvonIndeksi(T arvo) {
    for (int i = 0; i &lt; this.arvoja; i++) {
        if (this.arvot[i].equals(arvo)) {
            return i;
        }
    }

    return -1;
}
</code></pre>

<p>
  Toteutetaan tämän jälkeen metodi <code>private void siirraVasemmalle(int indeksistaLahtien)</code>, joka siirtää arvoja annetusta indeksistä lähtien vasemmalle.
</p>

<pre class="sh_java code-highlight"><code>private void siirraVasemmalle(int indeksistaLahtien) {
    for (int i = indeksistaLahtien; i &lt; this.arvoja - 1; i++) {
        this.arvot[i] = this.arvot[i + 1];
    }
}
</code></pre>

<p>
  Nyt metodi <code>poista</code> voidaan toteuttaa edellisten avulla hieman selkokielisemmäksi.
</p>

<pre class="sh_java code-highlight"><code>public void poista(T arvo) {
    int arvonIndeksi = arvonIndeksi(arvo);
    if (arvonIndeksi &lt; 0) {
        return; // ei löydy
    }

    siirraVasemmalle(arvonIndeksi);
    this.arvoja--;
}
</code></pre>

<div class="hint">
  <div class="hint__header">
    <i class="fa fa-info-circle hint__icon"></i>Edellä kuvatun poistomenetelmän tehokkuudesta
  </div>

  <div class="hint__body">
    
  <p>
    Edellä kuvattu menetelmä kopioi poiston yhteydessä jokaisen poistettua alkiota seuraavan alkion vasemmalle. Pohdi toteutuksen tehokkuutta tilanteessa, missä listaa käytetään jonona.
  </p>

  <p>
    Tämänkin menetelmän tehokkuuteen -- ja parannusehdotuksiin -- paneudutaan muunmuassa kursseilla Tietorakenteet ja algoritmit sekä Algoritmien suunnittelu ja analyysi.
  </p>


  </div>
</div>

<p>
  Luokassa lista on nyt hieman toistuvaa koodia. Metodi <code>sisaltaa</code> on hyvin samankaltainen metodin <code>arvonIndeksi</code> kanssa. Muokataan vielä metodia <code>sisaltaa</code> siten, että se toteutetaan metodin <code>arvonIndeksi</code> avulla.
</p>

<pre class="sh_java code-highlight"><code>public boolean sisaltaa(T arvo) {
    return arvonIndeksi(arvo) &gt;= 0;
}
</code></pre>

<p>
  Nyt käytössämme on lista, joka tarjoaa metodit <code>lisaa</code>, <code>sisaltaa</code>, ja <code>poista</code>. Lista myös kasvaa tarvittaessa. Listan toteutusta voisi toki vielä kehittää esimerkiksi lisäämällä toiminnallisuuden, mikä pienentää listan kokoa jos arvojen määrä pienenee hyvin pieneksi.
</p>

<pre class="sh_java code-highlight"><code>Lista&lt;String&gt; lista = new Lista&lt;&gt;();
System.out.println(lista.sisaltaa("hei"));
lista.lisaa("hei");
System.out.println(lista.sisaltaa("hei"));
lista.poista("hei");
System.out.println(lista.sisaltaa("hei"));
</code></pre>

<pre class="sample-output">false
true
false
</pre>


<h3 class="material-heading">
    Kohdasta hakeminen

</h3>

<p>
  Lisätään listalle vielä metodi <code>public T arvo(int indeksi)</code>, joka palauttaa listan tietyssä indeksissä sijaitsevan arvon. Mikäli ohjelmoija hakee arvoa listan ulkopuolelta, heitetään virhe <code>IndexOutOfBoundsException</code>. 
</p>

<pre class="sh_java code-highlight"><code>public T arvo(int indeksi) {
    if (indeksi &lt; 0 || indeksi &gt;= this.arvoja) {
        throw new ArrayIndexOutOfBoundsException("Indeksi " + indeksi + " alueen [0, " + this.arvoja + "[ ulkopuolella.");
    }

    return this.arvot[indeksi];
}
</code></pre>

<p>
  Metodin käyttöä edesauttaisi, mikäli luokan käyttäjällä olisi tieto haettavien arvojen indekseistä. Muutetaan vielä metodi <code>arvonIndeksi(T arvo)</code> kaikkien käytettäväksi, eli vaihdetaan sen näkyvyysmääre <code>private</code> muotoon <code>public</code>.
</p>

<pre class="sh_java code-highlight"><code>public int arvonIndeksi(T arvo) {
    for (int i = 0; i &lt; this.arvoja; i++) {
        if (this.arvot[i].equals(arvo)) {
            return i;
        }
    }

    return -1;
}
</code></pre>


<pre class="sh_java code-highlight"><code>Lista&lt;String&gt; lista = new Lista&lt;&gt;();
System.out.println(lista.sisaltaa("hei"));
lista.lisaa("hei");
System.out.println(lista.sisaltaa("hei"));
int indeksi = lista.arvonIndeksi("hei");
System.out.println(indeksi);
System.out.println(lista.arvo(indeksi));
lista.poista("hei");
System.out.println(lista.sisaltaa("hei"));
</code></pre>

<pre class="sample-output">false
true
0
hei
false
</pre>

<h3 class="material-heading">
    Listan koko

</h3>

<p>
  Lisätään listalle vielä metodi listan koon tarkastamiseen. Listan koon saa selville muuttujasta <code>arvoja</code>. 
</p> 

<pre class="sh_java code-highlight"><code>public int koko() {
    return this.arvoja;
}
</code></pre>

<p>
  Nyt listan alkioiden läpikäynti onnistuu mm. for-lauseella.
</p>

<pre class="sh_java code-highlight"><code>Lista&lt;String&gt; lista = new Lista&lt;&gt;();
lista.lisaa("hei");
lista.lisaa("maailma");

for(int i = 0; i &lt; lista.koko(); i++) {
    System.out.println(lista.arvo(i)); 
}
</code></pre>

<pre class="sample-output">hei
maailma
</pre>


<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Lista (2 osaa)</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Toteuta tehtäväpohjaan edellistä esimerkkiä noudattaen luokka <code>Lista</code>. Tehtäväpohjassa ei ole testejä -- kokeile listaa materiaalin esimerkkien ja omien kokeilujen avulla. Tehtävä on kahden pisteen arvoinen.
  </p>



    </div>
  </div>
</div>

<h2 class="material-heading">
    Hajautustaulu

</h2>

<p>
  Hajautustaulu on toteutettu taulukkona, missä jokainen alkio sisältää listan. Listalle tallennetaan (avain,arvo)-pareja. Käyttäjä voi hakea hajautustaulusta arvoja avaimen perusteella, ja toisaalta käyttäjä voi lisätä hajautustauluun avain-arvo -pareja. Kukin avain voi esiintyä hajautustaulussa korkeintaan kerran.
</p>

<p>
  Hajautustaulun toiminta perustuu avaimen hajautusarvoon. Kun hajautustauluun lisätään (avain,arvo)-pari, lasketaan avaimeen liittyvä hajautusarvo. Hajautusarvo määrää hajautustaulun sisäisen taulukon indeksin, missä olevaan listaan (avain,arvo)-pari lisätään.
</p>

<p>
  Hahmotellaan hajautustaulun toimintaa.
</p>


<h3 class="material-heading">
    Avain-arvo -pari

</h3>

<p>
  Luodaan ensin avain-arvo -paria kuvaava luokka <code>Pari</code>. Haluamme tehdä hajautustaulusta mahdollisimman yleiskäyttöisen, joten avaimen ja arvon tyyppi määrätään ajonaikaisesti. Pari sisältää avaimen ja arvon sekä niihin liittyvät get-metodit. Geneeriset tyypit K ja V ovat nimetty sanojen key ja value perusteella.
</p>

<pre class="sh_java code-highlight"><code>public class Pari&lt;K, V&gt; {

    private K avain;
    private V arvo;

    public Pari(K avain, V arvo) {
        this.avain = avain;
        this.arvo = arvo;
    }

    public K getAvain() {
        return avain;
    }

    public V getArvo() {
        return arvo;
    }

    public void setArvo(V arvo) {
        this.arvo = arvo;
    }
}
</code></pre>

<p>
  Avain-arvo -parien luominen on suoraviivaista.
</p>

<pre class="sh_java code-highlight"><code>Pari&lt;String, Integer&gt; pari = new Pari&lt;&gt;("yksi", 1);
System.out.println(pari.getAvain() + " -&gt; " + pari.getArvo());
</code></pre>


<pre class="sample-output">yksi -&gt; 1
</pre>


<h3 class="material-heading">
    Hajautustaulun luominen

</h3>

<p>
  Hajautustaulu sisältää taulukon listoja. Jokainen listan arvo on edellä kuvattu pari, joka sisältää avain-arvo -parin. Hajautustaululla on lisäksi tieto arvojen lukumäärästä. Tässä käytössämme on edellä luotu luokka <code>Lista</code>.
</p>

<pre class="sh_java code-highlight"><code>public class Hajautustaulu&lt;K, V&gt; {

    private Lista&lt;Pari&lt;K, V&gt;&gt;[] arvot;
    private int arvoja;

    public Hajautustaulu() {
        this.arvot = new Lista[32];
        this.arvoja = 0;
    }
}
</code></pre>


<h3 class="material-heading">
    Arvon hakeminen

</h3>

<p>
  Toteutetaan ensin metodi <code>public V hae(K avain)</code>, jota käytetään arvon hakemiseen avaimen perusteella.
</p>

<p>
  Metodissa lasketaan ensin avaimen hajautusarvo ja päätellään sen perusteella hajautustaulun sisäisen taulukon indeksi, mistä arvoja haetaan. Avaimen hajautusarvon laskemiseen käytetään jokaisella oliolla olevaa <code>hashCode</code>-metodia. Jakojäännöstä käytetään hajautusarvon hajautustaulun koon sisällä pysymiseen. 
</p>
  
<p>
  Mikäli hajautusarvon ja jakojäänneksen avulla lasketussa indeksissä ei ole listaa, ei indeksiin ole lisätty vielä yhtäkään avain-arvo -paria, eikä avaimelle ole tallennettu arvoa. Tällöin palautetaan null-viite. Muussa tapauksessa taulukon indeksissä oleva lista käydään läpi, ja avaimen yhtäsuuruutta vertaillaan jokaiseen listan avain-arvo -parin avaimeen. Mikäli joku listalla olevista avaimista vastaa avainta, jonka perusteella arvoa haetaan, palautetaan kyseinen arvo. Muulloin avainta (ja siihen liittyvää arvoa) ei löydy, ja palautetaan arvo null.
</p>

<pre class="sh_java code-highlight"><code>public V hae(K avain) {
    int hajautusArvo = Math.abs(avain.hashCode() % this.arvot.length);
    if (this.arvot[hajautusArvo] == null) {
        return null;
    }
  
    Lista&lt;Pari&lt;K, V&gt;&gt; arvotIndeksissa = this.arvot[hajautusArvo];

    for (int i = 0; i &lt; arvotIndeksissa.koko(); i++) {
        if (arvotIndeksissa.arvo(i).getAvain().equals(avain)) {
            return arvotIndeksissa.arvo(i).getArvo();
        }
    }
  
    return null;
}
</code></pre>


<div class="hint">
  <div class="hint__header">
    <i class="fa fa-info-circle hint__icon"></i>Miksei hajautustaulua toteuteta listana?
  </div>

  <div class="hint__body">
    
  <p>
    Hajautustaulun toimintaperiaate perustuu siihen, että avain-arvo -parit jaetaan hajautusarvon perusteella pieniin joukkoihin. Tällöin avaimen perusteella haettaessa käydään läpi vain hyvin pieni joukko avain-arvo -pareja -- olettaen toki, että hajautusarvo on järkevä.
  </p>

  <p>
    Jos hajautusarvo on aina sama -- esimerkiksi 1 -- vastaa hajautustaulun sisäinen toteutus listaa -- kaikki arvot ovat samalla listalla. Jos taas hajautusarvo on hyvin satunnainen, arvot hajautetaan mahdollisimman tasaisesti taulukon eri listoille.
  </p>

  <p>
    Hajautustaulu toimii lisäksi siten, että hajautustaulun käyttämää taulukkoa kasvatetaan mikäli arvojen määrä on tarpeeksi iso (tyypillisesti noin 75% taulukon koosta). Tyypillisesti miljoonia avain-arvo -pareja sisältävän hajautustaulun taulukon yhdessä indeksissä on vain muutama avain-arvo -pari. Tämä tarkoittaa käytännössä sitä, että avain-arvo -parin olemassaolon selvittämiseen tarvitaan vain hajautusarvon laskeminen sekä muutaman olion tarkastelu -- tämä on paljon nopeampaa kuin listan läpikäynti.
  </p>
  

  </div>
</div>


<h3 class="material-heading">
    Hajautustauluun lisääminen, osa 1

</h3>

<p>
  Toteutetaan hajautustauluun lisäämisen käytettävän metodin <code>public void lisaa(K avain, V arvo)</code> ensimmäinen versio. Ensimmäisessä versiossa hajautustaulun sisältämän taulukon kokoa ei kasvateta lisäyksen yhteydessä.
</p>

<p>
  Metodi laskee ensin avaimelle hajautusarvon ja päättelee hajautusarvon perusteella hajautustaulun sisäisen taulukon indeksin. Jos taulukon kyseisessä indeksissä ei ole arvoa, taulukon indeksiin lisätään lista. Tämän jälkeen taulukon indeksissä oleva lista käydään läpi ja sieltä etsitään avain-arvo -paria, jonka avain vastaa lisättävän avain-arvo -parin avainta. Mikäli vastaava avain löytyy, päivitetään olemassaolevan avain-arvo -parin arvo vastaamaan uutta avainta. Muulloin listaan lisätään uusi avain-arvo -pari -- tällöin myös hajautustaulussa olevien arvojen lukumäärää kasvatetaan yhdellä.
</p>

<pre class="sh_java code-highlight"><code>public void lisaa(K avain, V arvo) {
    int hajautusArvo = Math.abs(avain.hashCode() % arvot.length);
    if (arvot[hajautusArvo] == null) {
        arvot[hajautusArvo] = new Lista<>();
    }

    Lista&lt;Pari&lt;K, V&gt;&gt; arvotIndeksissa = arvot[hajautusArvo];

    int indeksi = -1;
    for (int i = 0; i &lt; arvotIndeksissa.koko(); i++) {
        if (arvotIndeksissa.arvo(i).getAvain().equals(avain)) {
            indeksi = i;
            break;
        }
    }

    if (indeksi &lt; 0) {
        arvotIndeksissa.lisaa(new Pari&lt;&gt;(avain, arvo));
        this.arvoja++;
    } else {
        arvotIndeksissa.arvo(indeksi).setArvo(arvo);
    }
}
</code></pre>

<p>
  Metodi on melko monimutkainen. Pilkotaan se pienempiin osiin -- ensimmäisen osan vastuulla on avaimeen liittyvän listan hakeminen ja toisen osan vastuulla on avaimen indeksin etsiminen listalta.
</p>

<pre class="sh_java code-highlight"><code>private Lista&lt;Pari&lt;K, V&gt;&gt; haeAvaimeenLittyvaLista(K avain) {
    int hajautusArvo = Math.abs(avain.hashCode() % arvot.length);
    if (arvot[hajautusArvo] == null) {
        arvot[hajautusArvo] = new Lista&lt;&gt;();
    }

    return arvot[hajautusArvo];
}
  
private int haeAvaimenIndeksi(Lista&lt;Pari&lt;K, V&gt;&gt; lista, K avain) {
    for (int i = 0; i &lt; lista.koko(); i++) {
        if (lista.arvo(i).getAvain().equals(avain)) {
            return i;
        }
    }

    return -1;
}
</code></pre>

<p>
  Nyt metodi <code>public void lisaa(K avain, V arvo)</code> voidaan toteuttaa hieman selkeämmin.
</p>

<pre class="sh_java code-highlight"><code>public void lisaa(K avain, V arvo) {
    Lista&lt;Pari&lt;K, V&gt;&gt; arvotIndeksissa = haeAvaimeenLittyvaLista(avain);
    int indeksi = haeAvaimenIndeksi(arvotIndeksissa, avain);
  
    if (indeksi &lt; 0) {
        arvotIndeksissa.lisaa(new Pari&lt;&gt;(avain, arvo));
        this.arvoja++;
    } else {
        arvotIndeksissa.arvo(indeksi).setArvo(arvo);
    }
}
</code></pre>


<h3 class="material-heading">
    Hajautustauluun lisääminen, osa 2

</h3>

<p>
  Edellä kuvattu hajautustauluun lisääminen toimii osittain. Toiminnallisuuden suurin puute on se, että taulukon kokoa ei kasvateta kun arvojen määrä kasvaa liian suureksi. Lisätään ohjelmaan kasvatustoiminnallisuus, mikä tuplaa hajautustaulun sisäisen taulukon koon. Kasvatustoiminnallisuuden tulee myös sijoittaa jokainen hajautustaulussa olevan taulukon arvo uuteen taulukkoon.
</p>

<p>
  Hahmotellaan kasvatustoiminnallisuuden alku. Kasvatustoiminnallisuudessa luodaan uusi taulukko, jonka koko on edelliseen verrattuna kaksinkertainen. Tämän jälkeen alkuperäinen taulukko käydään indeksi indeksiltä läpi ja olemassaolevat avain-arvo -parit kopioidaan uuteen taulukkoon. Lopulta alkuperäinen taulukko korvataan uudella taulukolla.
</p>

<p>
  Alla on hahmoteltu metodin toimintaa. Kopiointia ei ole vielä toteutettu.
</p>

<pre class="sh_java code-highlight"><code>private void kasvata() {
    // luodaan uusi taulukko
    Lista&lt;Pari&lt;K, V&gt;&gt;[] uusi = new Lista[this.arvot.length * 2];

    for (int i = 0; i &lt; this.arvot.length; i++) {
        // kopioidaan vanhan taulukon arvot uuteen

    }

    // korvataan vanha taulukko uudella
    this.arvot = uusi;
}
</code></pre>

<p>
  Hahmotellaan seuraavaksi metodia, joka kopioi alkuperäisen taulukon yhden indeksin sisältämän listan arvot uuteen taulukkoon. Kopioinnin yhteydessä jokaisen kopioitavan avain-arvo -parin sijainti taulukossa lasketaan uudelleen -- tämä tehdään, sillä taustalla olevan taulukon koko kasvaa ja avain-arvot -parit halutaan sijoittaa taulukkoon mahdollisimman tasaisesti.
</p>

<pre class="sh_java code-highlight"><code>private void kopioi(Lista&lt;Pari&lt;K, V&gt;&gt;[] uusi, int indeksista) {
    for (int i = 0; i &lt; this.arvot[indeksista].koko(); i++) {
        Pari&lt;K, V&gt; arvo = this.arvot[indeksista].arvo(i);
  
        int hajautusarvo = Math.abs(arvo.getAvain().hashCode() % uusi.length);
        if(uusi[hajautusarvo] == null) {
            uusi[hajautusarvo] = new Lista&lt;&gt;();
        }
  
        uusi[hajautusarvo].lisaa(arvo);
    }
}
</code></pre>

<p>
  Nyt kopioi-metodia voidaan kutsua kasvata-metodista.
</p>


<pre class="sh_java code-highlight"><code>private void kasvata() {
    // luodaan uusi taulukko
    Lista&lt;Pari&lt;K, V&gt;&gt;[] uusi = new Lista[this.arvot.length * 2];

    for (int i = 0; i &lt; this.arvot.length; i++) {
        // kopioidaan vanhan taulukon arvot uuteen
        kopioi(uusi, indeksista);
    }

    // korvataan vanha taulukko uudella
    this.arvot = uusi;
}
</code></pre>

<p>
  Lisätään lopuksi kasvatustoiminnallisuus osaksi lisäystoiminnallisuutta. Hajautustaulun kokoa kasvatetaan aina jos hajautustaulussa olevien avain-arvo -parien määrä on yli 75% taulukon koosta.
</p>

<pre class="sh_java code-highlight"><code>public void lisaa(K avain, V arvo) {
    Lista&lt;Pari&lt;K, V&gt;&gt; arvotIndeksissa = haeAvaimeenLittyvaLista(avain);
    int indeksi = haeAvaimenIndeksi(arvotIndeksissa, avain);

    if (indeksi &lt; 0) {
        arvotIndeksissa.lisaa(new Pari&lt;&gt;(avain, arvo));
        this.arvoja++;
    } else {
        arvotIndeksissa.arvo(indeksi).setArvo(arvo);
    }

    if (1.0 * this.arvoja / this.arvot.length &gt; 0.75) {
        kasvata();
    }
}
</code></pre>



<h3 class="material-heading">
    Poistaminen

</h3>

<p>
  Lisätään hajautustauluun vielä toiminnallisuus avain-arvo -parin poistamiseen avaimen perusteella. Poistotoiminnallisuus palauttaa null-arvon mikäli arvoa ei löydy, muuten metodi palauttaa poistettavaan avaimeen liittyvän arvon.
</p>

<p>
  Voimme hyödyntää valmiiksi toteuttamiamme metodeja poistotoiminnallisuudessa. Selitä itsellesi (ääneen) alla olevan metodin konkreettinen toiminta.
</p>


<pre class="sh_java code-highlight"><code>public V poista(K avain) {
    Lista&Lt;Pari&lt;K, V&gt;&gt; arvotIndeksissa = haeAvaimeenLittyvaLista(avain);
    if (arvotIndeksissa.koko() == 0) {
        return null;
    }

    int indeksi = haeAvaimenIndeksi(arvotIndeksissa, avain);
    if (indeksi &lt; 0) {
        return null;
    }

    Pari&lt;K, V&gt; pari = arvotIndeksissa.arvo(indeksi);
    arvotIndeksissa.poista(pari);
    return pari.getArvo();
}
</code></pre>


<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Hajautustaulu (3 osaa)</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Toteuta tehtäväpohjaan edellistä esimerkkiä noudattaen luokka Hajautustaulu. Toisin kuin esimerkissä, toteuta luokka siten, että se hyödyntää sisäisessä toteutuksessa Listan sijaan Javan valmista luokkaa ArrayList. Tehtäväpohjassa ei ole testejä -- kokeile listaa materiaalin esimerkkien ja omien kokeilujen avulla. Tehtävä on kolmen pisteen arvoinen.
  </p>

  
  


    </div>
  </div>
</div>


<h2 class="material-heading">
    Hakemisen tehokkuudesta

</h2>

<p>
  Tarkastellaan vielä hakemisen tehokkuutta listasta ja hajautustaulusta. Tehokkuusmittauksia voi tehdä metodin <code>System.nanotime()</code> palauttaman nanosekunteja kuvaavan arvon avulla. Ohjelma luo ensin miljoona alkiota hajautustauluun ja listaan, jonka jälkeen hajautustaulusta ja listasta etsitään tuhatta satunnaista arvoa. Noin 50% arvoista löytyy listalta ja hajautustaulusta.
</p>

<pre class="sh_java code-highlight"><code>Lista&lt;String&gt; lista = new Lista&lt;&gt;();
Hajautustaulu&lt;String, String&gt; taulu = new Hajautustaulu&lt;&gt;();

for (int i = 0; i &lt; 1000000; i++) {
    lista.lisaa("" + i);
    taulu.lisaa("" + i, "" + i);
}

Lista&lt;String&gt; haettavat = new Lista&lt;&gt;();
Random arpoja = new Random();
for (int i = 0; i &lt; 1000; i++) {
    haettavat.lisaa("" + arpoja.nextInt(2000000));
}

long listanHakuAloitus = System.nanoTime();
for (int i = 0; i &lt; haettavat.koko(); i++) {
    lista.sisaltaa(haettavat.arvo(i));            
}
long listanHakuLopetus = System.nanoTime();
  
long hajautustaulunHakuAloitus = System.nanoTime();
for (int i = 0; i &lt; haettavat.koko(); i++) {
    taulu.hae(haettavat.arvo(i));            
}
long hajautustaulunHakuLopetus = System.nanoTime();

  
long listanHaku = listanHakuLopetus - listanHakuAloitus;
System.out.println("Lista: haku kesti noin " + listanHaku / 1000000 + " millisekuntia (" +
    listanHaku + " nanosekuntia.)");
  
long hajautustaulunHaku = hajautustaulunHakuLopetus - hajautustaulunHakuAloitus;
System.out.println("Hajautustaulu: haku kesti noin " + hajautustaulunHaku / 1000000 +
    " millisekuntia (" + hajautustaulunHaku + " nanosekuntia.)");
</code></pre>


<pre class="sh_java code-highlight"><code>Lista: haku kesti noin 6284 millisekuntia (6284420580 nanosekuntia.)
Hajautustaulu: haku kesti noin 0 millisekuntia (805106 nanosekuntia.)
</code></pre>

<p>
  <em>
    Edellä kuvatut ja kursseilla käyttämämme listat ja hajautustaulut poikkeavat toki sisäiseltä toteutukselta hieman toisistaan. Ohjelmointikielten tarjoamissa tietorakenteissa on hieman enemmän erilaisia optimointeja -- näihinkin palataan myöhemmillä kursseilla. Tämän kurssin puitteissa riittää em. tietorakenteiden käyttöosaaminen sekä jonkintasoinen ymmärrys niiden tehokkuuseroista sekä käyttötapauksista.
  </em>
</p>


<h1 class="material-heading">
    Satunnaisuus ohjelmissa

</h1>

<div class="learning-objectives">
  <div class="learning-objectives__header">
    <i class="fa fa-user-graduate learning-objectives__icon"></i>Oppimistavoitteet
  </div>

  <div class="learning-objectives__body">
    
  <ul>
    <li>
      Tiedät miten satunnaislukuja luodaan ja tiedät joitakin tilanteita missä satunnaislukuja tarvitaan.
    </li>
    <li>
      Osaat käyttää Javan valmista Random-luokkaa satunnaislukujen luomiseen.
    </li>
  </ul>


  </div>
</div>

<p>
  Satunnaisuutta tarvitaan esimerkiksi salausalgoritmeissa, koneoppimisessa sekä tietokonepelien ennustettavuuden vähentämisessä. Satunnaisuutta mallinnetaan käytännössä satunnaislukujen avulla, joiden luomiseen Java tarjoaa valmiin <code>Random</code>-luokan. Random-luokasta voi tehdä olion jota voi käyttää seuraavalla tavalla.
</p>

<pre class="sh_java code-highlight"><code>import java.util.Random;

public class Arvontaa {
    public static void main(String[] args) {
        Random arpoja = new Random(); // luodaan apuväline arpoja

        for (int i = 0; i &lt; 10; i++) {
            // Arvotaan ja tulostetaan satunnainen luku
            int luku = arpoja.nextInt(10);
            System.out.println(luku);
        }
    }
}
</code></pre>

<p>
  Yllä olevassa esimerkissä luodaan ensin <code>Random</code>-luokasta olio. Random-olio tarjoaa metodin <code>nextInt</code>, jolle annetaan parametrina kokonaisluku. Metodi palauttaa satunnaisen kokonaisluvun väliltä <code>[0,kokonaisluku[</code> eli <em>0..(annettu kokonaisluku - 1)</em>.
</p>

<p>
  Ohjelman tuottama tulostus ei ole aina sama. Yksi mahdollinen tulostusesimerkki on seuraava:
</p>

<pre class="sample-output">2
2
4
3
4
5
6
0
7
8
</pre>

<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Lukuja</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Kirjoita ohjelma, joka kysyy käyttäjältä tulostettavien satunnaislukujen määrän ja tulostaa tämän jälkeen luvut. Tulostettavien lukujen tulee olla välillä <code>[0, 10]</code>. Alla muutamia esimerkkejä.
  </p>

<pre class="sample-output">Montako satunnaislukua tulostetaan?
<font color="red">4</font>
9
1
4
3
</pre>


<pre class="sample-output">Montako satunnaislukua tulostetaan?
<font color="red">8</font>
9
6
0
9
10
7
3
3
</pre>



        <hr/>

        Tehtävään on olemassa esimerkkiratkaisu <a href="https://tmc.mooc.fi/" target="_blank" rel="noopener">Test My Code</a> -järjestelmässä. Esimerkkiratkaisua voi käyttää oman oppimisen tukena, ja se on tarkasteltavissa jo ennen kuin olet saanut tehtävän valmiiksi. Esimerkkiratkaisuun pääset käsiksi <a href="https://tmc.mooc.fi/exercises/53843/solution" target="_blank" rel="noopener">täältä</a>. Huomaathan, että tehtävän voi ratkaista monella tapaa, ja tässä annettu esimerkkiratkaisu on näistä vain yksi.

    </div>
  </div>
</div>

<p>
  Metodin <code>nextInt</code> avulla pystyy luomaan hyvin monipuolista satunnaisuutta. Ohjelmoija saattaisi esimerkiksi haluta, että ohjelman ilmoittama lämpötila on satunnainen ja väliltä [-30,50]. Tällöin ratkaisu on arpoa lukuja nollan ja kahdeksankymmenen väliltä ja miinustaa arvotusta luvusta 30.
</p>


<pre class="sh_java code-highlight"><code>Random arpoja = new Random();
int lampotila = arpoja.nextInt(81) - 30;
System.out.println(lampotila);
</code></pre>

<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Noppa</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Tehtäväpohjassa on luokka <code>Noppa</code>, jonka runko on seuraava:
  </p>

<pre class="sh_java code-highlight"><code>import java.util.Random;

public class Noppa {
    private Random random;
    private int tahkojenMaara;

    public Noppa(int tahkojenMaara) {
        this.random = new Random();
        // Alusta oliomuuttuja tahkojenMaara tässä
    }

    public int heita() {
        // arvo täällä luku jonka tulee olla yhdestä tahkojen määrään
        // ja palauta se
    }
}
</code></pre>

  <p>
    Muokkaa luokkaa siten, että sen konstruktori<code>Noppa(int tahkojenMaara)</code> luo uuden noppa-olion annetulla nopan tahkojen (eri oman numeronsa sisältämien "puolien") määrällä. Muokkaa myös metodia <code>heita</code> siten, että se antaa satunnaisen nopanheiton tuloksen, jonka arvon tulee olla väliltä <code>1...tahkojen määrä</code>.
  </p>

  <p>
    Seuraavassa noppaa testaava pääohjelma:
  </p>

<pre class="sh_java code-highlight"><code>public class Ohjelma {
    public static void main(String[] args) {
        Noppa noppa = new Noppa(6);

        for (int i = 0; i &lt; 10; i++) {
            System.out.println(noppa.heita());
        }
    }
}
</code></pre>

  <p>
    Tulostus voisi olla esimerkiksi seuraava:
  </p>

<pre class="sample-output">1
6
3
5
3
3
2
2
6
1
</pre>



        <hr/>

        Tehtävään on olemassa esimerkkiratkaisu <a href="https://tmc.mooc.fi/" target="_blank" rel="noopener">Test My Code</a> -järjestelmässä. Esimerkkiratkaisua voi käyttää oman oppimisen tukena, ja se on tarkasteltavissa jo ennen kuin olet saanut tehtävän valmiiksi. Esimerkkiratkaisuun pääset käsiksi <a href="https://tmc.mooc.fi/exercises/53844/solution" target="_blank" rel="noopener">täältä</a>. Huomaathan, että tehtävän voi ratkaista monella tapaa, ja tässä annettu esimerkkiratkaisu on näistä vain yksi.

    </div>
  </div>
</div>

<p>
  Random-luokasta tehdyn olion kautta päästään käsiksi myös satunnaisiin liukulukuihin, joita käytetään muunmuassa todennäköisyyslaskennan yhteydessä; tietokoneilla todennäköisyyksiä simuloidaan yleensä väliltä [0..1] olevilla luvuilla.
</p>

<p>
  Random-oliolta satunnaisia liukulukuja saa metodilla <code>nextDouble</code>. Tarkastellaan seuraavia säämahdollisuuksia:
</p>

<ul>
  <li>Sataa räntää todennäköisyydellä 0.1 (10%)</li>
  <li>Sataa lunta todennäköisyydellä 0.3 (30%)</li>
  <li>Aurinko paistaa todennäköisyydellä 0.6 (60%)</li>
</ul>

<p>
  Luodaan edellä olevista arvioista sääennustaja.
</p>

<pre class="sh_java code-highlight"><code>import java.util.ArrayList;
import java.util.Random;

public class SaaEnnustaja {
    private Random random;

    public SaaEnnustaja() {
        this.random = new Random();
    }

    public String ennustaSaa() {
        double todennakoisyys = this.random.nextDouble();

        if (todennakoisyys &lt;= 0.1) {
            return "Sataa räntää";
        } else if (todennakoisyys &lt;= 0.4) { // 0.1 + 0.3
            return "Sataa lunta";
        } else { // loput, 1.0 - 0.4 = 0.6
            return "Aurinko paistaa";
        }
    }

    public int ennustaLampotila() {
        return (int) (4 * this.random.nextGaussian() - 3);
    }
}
</code></pre>

<p>
  Metodi <code>ennustaLampotila</code> on monella tapaa mielenkiintoinen. Metodin sisällä tehtävä kutsu <code>this.random.nextGaussian()</code> on tavallinen metodikutsu, jonka kaltaisia olemme nähneet aikaisemminkin. Kiinnostavaa tässä <code>Random</code>-luokan ilmentymän tarjoamassa metodissa on se, että metodin palauttama luku on normaalijakautunut (normaalijakautuneilla luvuilla voi kuvata esimerkiksi ihmisten pituuksia ja painoja -- jos et koe mielenkiintoa satunnaisuuden eri lajeihin se ei haittaa!).
</p>

<pre class="sh_java code-highlight"><code>public int ennustaLampotila() {
    return (int) (4 * this.random.nextGaussian() - 3);
}
</code></pre>

<p>
  Edellisessä esimerkissä käytetään eksplisiittistä tyyppimuunnosta liukulukujen muuntamiseen kokonaisluvuiksi <code>(int)</code>. Vastaavalla menetelmällä voidaan muuttaa myös kokonaislukuja liukuluvuiksi kirjoittamalla <code>(double) kokonaisluku</code>
</p>

<p>
  Luodaan vielä pääohjelma josta luokkaa <code>SaaEnnustaja</code> käytetään.
</p>

<pre class="sh_java code-highlight"><code>// importit 

public class Ohjelma {

    public static void main(String[] args) {
        SaaEnnustaja ennustaja = new SaaEnnustaja();

        // tallennetaan päivät listalle
        ArrayList&lt;String&gt; paivat = new ArrayList&lt;&gt;();
        paivat.add("Ma");
        paivat.add("Ti");
        paivat.add("Ke");
        paivat.add("To");
        paivat.add("Pe");
        paivat.add("La");
        paivat.add("Su");

        System.out.println("Seuraavan viikon sääennuste:");

        for (String paiva: paivat) {
            String saaEnnuste = ennustaja.ennustaSaa();
            int lampotilaEnnuste = ennustaja.ennustaLampotila();

            System.out.println(paiva + ": " + saaEnnuste + " " + lampotilaEnnuste + " astetta.");
        }
    }
}
</code></pre>

<p>
  Ohjelman tulostus voisi olla esimerkiksi seuraavanlainen:
</p>

<pre class="sample-output">Seuraavan viikon sääennuste:
Ma: Sataa lunta 1 astetta.
Ti: Sataa lunta 1 astetta.
Ke: Aurinko paistaa -2 astetta.
To: Aurinko paistaa 0 astetta.
Pe: Sataa lunta -3 astetta.
La: Sataa lunta -3 astetta.
Su: Aurinko paistaa -5 astetta
</pre>

<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Lottoarvonta</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Tehtävänäsi on täydentää luokkaa <code>Lottorivi</code>, joka arpoo viikon lottonumerot. Lottonumerot ovat väliltä 1&ndash;40 ja niitä arvotaan 7. Lottorivi koostuu siis seitsemästä eri numerosta väliltä 1&ndash;40.
  </p>
  <p>
    Luokalle toivotaan seuraava toiminnot:
  </p>

  <ul>
    <li>
      konstruktori <code>Lottorivi</code> luo uuden Lottorivi-olion joka sisältää uudet, arvotut numerot
    </li>
    <li>
      metodi <code>numerot</code> palauttaa tämän lottorivin lottonumerot
    </li>
    <li>
      metodi <code>sisaltaaNumeron</code> kertoo onko arvotuissa numeroissa annettu numero
    </li>
    <li>
      metodi <code>arvoNumerot</code> arpoo riville uudet numerot
    </li>
  </ul>

  <p>
    Luokan runko on seuraava:
  </p>

<pre class="sh_java code-highlight"><code>import java.util.ArrayList;
import java.util.Random;

 public class LottoRivi {
    private ArrayList&lt;Integer&gt; numerot;

    public LottoRivi() {
        this.arvoNumerot();
    }

    public ArrayList&lt;Integer&gt; numerot() {
        return this.numerot;
    }

    public boolean sisaltaaNumeron(int numero) {
        // Testaa tässä onko numero jo arvottujen numeroiden joukossa
        return false;
    }

    public void arvoNumerot() {
        // alustetaan lista numeroille
        this.numerot = new ArrayList&lt;&gt;();
        // Kirjoita numeroiden arvonta tänne käyttämällä metodia sisaltaaNumeron()
    }

    public boolean equals(Object toinen) {
        return false;
    }
}
</code></pre>

  <p>
    Tehtäväpohjan mukana tulee seuraava pääohjelma:
  </p>

<pre class="sh_java code-highlight"><code>import java.util.ArrayList;

public class Ohjelma {
    public static void main(String[] args) {
        Lottorivi rivi = new Lottorivi();
        ArrayList&lt;Integer&gt; lottonumerot = rivi.numerot();

        System.out.println("Lottonumerot:");
        for (int numero: lottonumerot) {
            System.out.print(numero + " ");
        }

        System.out.println("");
    }
}
</code></pre>

  <p>
    Ohjelman mahdollisia tulostuksia ovat seuraavat:
  </p>

<pre class="sample-output">Lottonumerot:
3 5 10 14 15 27 37
</pre>

<pre class="sample-output">Lottonumerot:
2 9 11 18 23 32 34
</pre>

  <p>
    <strong>Huom!</strong> Sama numero saa esiintyä lottorivissä vain kerran. Lottorivin numeroiden ei tarvitse olla järjestyksessä.
  </p>



        <hr/>

        Tehtävään on olemassa esimerkkiratkaisu <a href="https://tmc.mooc.fi/" target="_blank" rel="noopener">Test My Code</a> -järjestelmässä. Esimerkkiratkaisua voi käyttää oman oppimisen tukena, ja se on tarkasteltavissa jo ennen kuin olet saanut tehtävän valmiiksi. Esimerkkiratkaisuun pääset käsiksi <a href="https://tmc.mooc.fi/exercises/53845/solution" target="_blank" rel="noopener">täältä</a>. Huomaathan, että tehtävän voi ratkaista monella tapaa, ja tässä annettu esimerkkiratkaisu on näistä vain yksi.

    </div>
  </div>
</div>

<div class="hint">
  <div class="hint__header">
    <i class="fa fa-info-circle hint__icon"></i>Lukujen satunnaisuudesta
  </div>

  <div class="hint__body">
    
  <p>
    Tietokoneiden toiminta on ennustettavissa sillä ne suorittavat niille annettuja komentoja orjallisesti. Ovatko siis tietokoneen luomat luvut todellisuudessa satunnaisia?
  </p>

  <p>
    Tietokoneohjelmissa käytetyt satunnaisluvut ovat tyypillisesti pseudosatunnaislukuja, eli ne vaikuttavat satunnaisluvuilta, mutta seuraavat todellisuudessa jonkinlaista algoritmisesti luotua toistuvaa lukusarjaa. Suurimmalle osalle tietokoneohjelmista pseudosatunnaisluvut ovat riittävän hyviä -- esimerkiksi youtube-videoiden satunnaisessa toistossa normaali käyttäjä tuskin huomaa eroa. Toisaalta, jos satunnaislukuja käytetään tieteelliseen laskentaan, heikosti toimivat pseudosatunnaislukuja luovat algoritmit saattavat jopa johtaa tulosten kyseenalaistamiseen. Eräs esimerkki tällaisesta on hetken 1960-luvulla käytössä ollut IBM:n <a href="https://en.wikipedia.org/wiki/RANDU" target="_blank" norel>RANDU</a>.
  </p>

  <p>
    Kaikki tietokoneohjelmien satunnaisuus ei kuitenkaan ole pseudosatunnaisuutta. Vahvempaan satunnaisuuteen pyrkivät ohjelmat hyödyntävät muunmuassa jonkinlaisia tosielämän satunnaiseksi ajateltuja ilmiöitä satunnaislukujen luomiseen. Tällaisia ilmiöitä ovat esimerkiksi avaruussäteily tai vaikkapa <a href="https://www.wired.com/2003/08/random/" target="_blank" norel>laavalamppujen toiminta</a>.
  </p>

  <p>
    Lisää aiheesta osoitteessa <a href="https://www.random.org/randomness/" target="_blank" norel>https://www.random.org/randomness/</a>.
  </p>


  </div>
</div>


<h1 class="material-heading">
    Moniulotteinen tieto

</h1>

<div class="learning-objectives">
  <div class="learning-objectives__header">
    <i class="fa fa-user-graduate learning-objectives__icon"></i>Oppimistavoitteet
  </div>

  <div class="learning-objectives__body">
    
  <ul>
    <li>
      Tunnet menetelmiä moniulotteisen tiedon esittämiseen.
    </li>
    <li>
      Osaat luoda ja käyttää moniulotteisia taulukoita.
    </li>
  </ul>


  </div>
</div>


<p>
  Aiemmat esimerkkimme ovat käsitelleet yksiulotteisia taulukoita, missä indeksi kertoo sijainnin yhdessä ulottuvuudessa. Taulukon voi luoda myös useampiulotteisena, jolloin taulukossa olevaa tietoa voi tarkastella useamman indeksin avulla. Tämä on kätevää esimerkiksi silloin, jos tieto on useampiulotteista kuten esimerkiksi koordinaatistossa.
</p>

<p>
  Kaksiulotteinen taulukko, jossa on kaksi riviä ja kolme saraketta, luodaan seuraavasti:
</p>

<pre class="sh_java code-highlight"><code>int rivit = 2;
int sarakkeet = 3;
int[][] kaksiulotteinenTaulukko = new int[rivit][sarakkeet];
</code></pre>

<p>
  Yllä luomme taulukon, jonka jokainen rivi viittaa taulukkoon, jossa on tietty määrä sarakkeita. Kaksiulotteisen taulukon läpikäynti onnistuu kahden sisäkkäisen for-toistolauseen avulla seuraavasti:
</p>

<pre class="sh_java code-highlight"><code>int rivit = 2;
int sarakkeet = 3;
int[][] kaksiulotteinenTaulukko = new int[rivit][sarakkeet];

System.out.println("rivi, sarake, arvo");
for (int rivi = 0; rivi &lt; kaksiulotteinenTaulukko.length; rivi++) {
    for (int sarake = 0; sarake &lt; kaksiulotteinenTaulukko[y].length; sarake++) {
        int arvo = kaksiulotteinenTaulukko[rivi][sarake];
        System.out.println("" + rivi + ", " + sarake + ", " + arvo);
    }
}
</code></pre>

<p>
  Ylläolevan ohjelman tulostus on seuraava.
</p>

<pre class="sample-output">rivi, sarake, arvo
0, 0, 0
0, 1, 0
0, 2, 0
1, 0, 0
1, 1, 0
1, 2, 0
</pre>

<p>
  Yllä huomataan että int-tyyppisten muuttujien oletusarvo on 0.
</p>

<p>
  Voimme muuttaa taulukon arvoja kuten ennenkin. Alla asetamme kahteen kohtaan uudet arvot.
</p>

<pre class="sh_java code-highlight"><code>int rivit = 2;
int sarakkeet = 3;
int[][] kaksiulotteinenTaulukko = new int[rivit][sarakkeet];

kaksiulotteinenTaulukko[0][1] = 4;
kaksiulotteinenTaulukko[1][1] = 1;
kaksiulotteinenTaulukko[1][0] = 8;

System.out.println("rivi, sarake, arvo");
for (int rivi = 0; rivi &lt; kaksiulotteinenTaulukko.length; rivi++) {
    for (int sarake = 0; sarake &lt; kaksiulotteinenTaulukko[y].length; sarake++) {
        int arvo = kaksiulotteinenTaulukko[rivi][sarake];
        System.out.println("" + rivi + ", " + sarake + ", " + arvo);
    }
}
</code></pre>

<p>
  Nyt tulostus näyttää seuraavalta:
</p>

<pre class="sample-output">rivi, sarake, arvo
0, 0, 0
1, 0, 4
2, 0, 0
0, 1, 8
1, 1, 1
2, 1, 0
</pre>


<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Taulukko merkkijonona</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    Luo tehtäväpohjaan metodi <code>public static String taulukkoMerkkijonona(int[][] taulukko)</code>, joka muodostaa parametrina saamastaan taulukosta merkkijonomuotoisen esityksen ja palauttaa sen.
  </p>

  <p>
    Kertaa yhdeksännen osan kohta 3.2. StringBuilder ennen tehtävän tekoa. Alla muutamia esimerkkejä metodin odotetusta toiminnasta.
  </p>

<pre class="sh_java code-highlight"><code>int rivit = 2;
int sarakkeet = 3;
int[][] matriisi = new int[rivit][sarakkeet];
matriisi[0][1] = 5;
matriisi[1][0] = 3;
matriisi[1][2] = 7;
System.out.println(taulukkoMerkkijonona(matriisi));
</code></pre>
 
<pre class="sample-output">050
307
</pre>
  
<pre class="sh_java code-highlight"><code>int[][] matriisi = {
  {3, 2, 7, 6},
  {2, 4, 1, 0},
  {3, 2, 1, 0}
};

System.out.println(taulukkoMerkkijonona(matriisi));
</code></pre>

<pre class="sample-output">3276
2410
3210
</pre>
  


        <hr/>

        Tehtävään on olemassa esimerkkiratkaisu <a href="https://tmc.mooc.fi/" target="_blank" rel="noopener">Test My Code</a> -järjestelmässä. Esimerkkiratkaisua voi käyttää oman oppimisen tukena, ja se on tarkasteltavissa jo ennen kuin olet saanut tehtävän valmiiksi. Esimerkkiratkaisuun pääset käsiksi <a href="https://tmc.mooc.fi/exercises/53846/solution" target="_blank" rel="noopener">täältä</a>. Huomaathan, että tehtävän voi ratkaista monella tapaa, ja tässä annettu esimerkkiratkaisu on näistä vain yksi.

    </div>
  </div>
</div>


<div class="exercise">
  <div class="exercise__header">
    <a data-toggle="collapse" class="exercise__toggle">
      <i class="fa fa-pencil-alt exercise__icon"></i>
      <h1 class="exercise__heading">Taikaneliö (4 osaa)</h1>

      <i class="fa fa-caret-down exercise__arrow"></i>
    </a>
  </div>

  <div class="collapse">
    <div class="exercise__body">
      
  <p>
    <a href="https://fi.wikipedia.org/wiki/Taikaneli%C3%B6" target="_blank">Taikaneliöt</a> ovat kokonaisluvuista järjestettyjä neliöitä, joiden jokaisen rivin, sarakkeen ja lävistäjän summa on sama. Harjoitellaan taulukoiden käyttöä taikaneliöiden yhteydessä.
  </p>

  <p>
    Ohjelmassa on annettu osittain toteutettu luokka <code>Taikanelio</code>, jota voidaan käyttää lähtökohtana. Tehtävänäsi on ensin lisätä luokkaan toiminnallisuutta, jolla tarkistetaan onko neliö taikaneliö. Tämän jälkeen toteutat algoritmin taikaneliön luomiseen.
  </p>

  <h2>Rivien summat</h2>

  <p>
    Luokassa Taikanelio on valmiina metodi <code>public ArrayList&lt;Integer&gt; rivienSummat()</code>, joka palauttaa tyhjän ArrayList-olion. Muuta metodin toiminnallisuutta siten, että se palauttaa listan, jossa on jokaisen taikaneliön rivin summa.
  </p>

  <p>
    Esimerkiksi seuraavanlaisella taikaneliöllä rivienSummat-metodin pitäisi palauttaa lista, jossa on luvut <code>15, 15, 15</code>.
  </p>

<pre> 
8 1 6 
3 5 7
4 9 2</pre>

  <p>
    Vaikka taikaneliö ei olisi "oikea" taikaneliö, tulee rivien summat silti palauttaa. Allaolevalla esimerkillä rivienSummat-metodin pitäisi palauttaa lista, jossa on luvut <code>6, 15, 24</code>.
  </p>

<pre> 
1 2 3
4 5 6
7 8 9</pre>


  <h2>Sarakkeiden summat</h2>

  <p>
    Luokassa Taikanelio on valmiina metodi <code>public ArrayList&lt;Integer&gt; sarakkeidenSummat()</code>, joka palauttaa tyhjän ArrayList-olion. Muuta metodin toiminnallisuutta siten, että se palauttaa listan, jossa on jokaisen taikaneliön sarakkeen summa.
  </p>

  <p>
    Esimerkiksi seuraavanlaisella taikaneliöllä sarakkeidenSummat-metodin pitäisi palauttaa lista, jossa on luvut <code>15, 15, 15</code>.
  </p>

<pre> 
8 1 6 
3 5 7
4 9 2</pre>

  <p>
    Vaikka taikaneliö ei olisi "oikea" taikaneliö, tulee sarakkeiden summat silti palauttaa. Allaolevalla esimerkillä sarakkeidenSummat-metodin pitäisi palauttaa lista, jossa on luvut <code>12, 15, 18</code>.
  </p>

<pre> 
1 2 3
4 5 6
7 8 9</pre>


  <h2>Lävistäjien summat</h2>

  <p>
    Toteuta seuraavaksi metodi <code>public ArrayList&lt;Integer&gt; lavistajienSummat()</code>, joka palauttaa listan, jossa on taikaneliön lävistäjien summat.
  </p>

  <p>
    Esimerkiksi seuraavanlaisella taikaneliöllä lavistajienSummat-metodin pitäisi palauttaa lista, jossa on luvut <code>15, 15</code> (8 + 5 + 2) ja (4 + 5 + 6).
  </p>

<pre> 
8 1 6 
3 5 7
4 9 2</pre>

  <p>
    Vaikka taikaneliö ei olisi "oikea" taikaneliö, tulee lävistäjien summat silti palauttaa. Allaolevalla esimerkillä lavistajienSummat-metodin pitäisi palauttaa lista, jossa on luvut <code>15, 15</code> (1 + 5 + 9) ja (7 + 5 + 3).
  </p>

<pre> 
1 2 3
4 5 6
7 8 9</pre>


  <h2>Taikaneliön luominen</h2>

  <p>
    Huom! Tämä tehtävä on melko visainen, kannattanee palauttaa edelliset osat ennen tämän aloitusta.
  </p>

  <p>
    Taikaneliön pystyy myös luomaan. Tutustutaan <a href="https://en.wikipedia.org/wiki/Siamese_method" target="_blank">Siamese method</a>-menetelmään, jonka avulla voidaan luoda parittomien lukujen kokoisia taikaneliöitä.
  </p>

  <p>
    Siamese method -algoritmi toimii siten, että numero yksi asetetaan ylimmän rivin keskimmäiseen sarakkeeseen. Tämän jälkeen siirrytään yksi ylös ja yksi oikealle ja asetetaan luku kaksi. Tämän jälkeen taas siirrytään yksi ylös ja yksi oikealle, ja asetetaan luku kolme jne.
  </p>
  
  <p>
    Lukujen lisäämiseen liittyy kaksi sääntöä:
  </p>

  <ol>
    <li>
      Jos siirtymä tapahtuu siten, että mennään taikaneliön alueen ulkopuolelle, hypätään toiselle laidalle. Jos siis mennään "oikealta yli" mennään vasempaan laitaan ja jos mennään "ylhäältä yli" mennään alalaitaan.
    </li>
    <li>
      Jos kohdassa on jo luku, ei mennäkään ylös ja oikealle, vaan astutaan yksi askel alaspäin.
    </li>
  </ol>


  <figure>
    <img class="naytto" src="../img/taikaneliot-siamese-29249c37.gif"/>

    <figcaption><p>Siamese method -algoritmin suoritus. Kuva Wikipediasta (<a href="https://en.wikipedia.org/wiki/Siamese_method" target="_blank">Siamese method</a>).</p></figcaption>
  </figure>

  <p>
    Toteuta parittomien taikalukujen luominen luokan <code>Taikaneliotehdas</code> metodiin <code>luoTaikanelio</code>. Metodin tarvitsee toimia vain tilanteissa, missä neliön leveys on pariton luku.
  </p>



        <hr/>

        Tehtävään on olemassa esimerkkiratkaisu <a href="https://tmc.mooc.fi/" target="_blank" rel="noopener">Test My Code</a> -järjestelmässä. Esimerkkiratkaisua voi käyttää oman oppimisen tukena, ja se on tarkasteltavissa jo ennen kuin olet saanut tehtävän valmiiksi. Esimerkkiratkaisuun pääset käsiksi <a href="https://tmc.mooc.fi/exercises/53847/solution" target="_blank" rel="noopener">täältä</a>. Huomaathan, että tehtävän voi ratkaista monella tapaa, ja tässä annettu esimerkkiratkaisu on näistä vain yksi.

    </div>
  </div>
</div>


<div class="hint">
  <div class="hint__header">
    <i class="fa fa-info-circle hint__icon"></i>Taulukko vs. Hajautustaulu
  </div>

  <div class="hint__body">
    
  <p>
    Taulukon toiminnallisuutta vastaavan toiminnallisuuden pystyy toteuttamaan hajautustaulun avulla. Eikö hajautustaulun käyttö olisi yleisesti ottaen parempi vaihtoehto, sillä sitä ei esimerkiksi tarvitse kasvattaa lainkaan?
  </p>

  <p>
    Kun hajautustaulusta haetaan tietoa tietyllä avaimella, metodin hashCode perusteella selvitetään paikka, mistä tietoa haetaan. Samassa paikassa voi olla useampi arvo (listassa), jolloin haettavaa avainta verrataan jokaiseen listalla olevaan arvoon equals-metodia käyttäen. Kun taulukosta haetaan arvoa tietyllä avaimella -- eli indeksillä -- ei vastaavaa toiminnallisuutta tarvitse tehdä. Taulukossa joko on arvo tai arvoa ei ole. Taulukkoon liittyy pieni tehokkuushyöty ohjelman suorituskyvyn kannalta.
  </p>

  <p>
    Tämä tehokkuushyöty kuitenkin tulee lisääntyneen virhealttiuden sekä työmäärän kustannuksella. Hajautustauluun on valmiiksi toteutettuna sisäisen taulukon kasvattaminen ja sen toiminnallisuutta on testattu hyvin laajasti. Taulukkoa käytettäessä tällaista etua ei ole -- uutta toiminnallisuutta toteuttaessa saattaa päätyä virheisiin, mikä kasvattaa työmäärää. Virheet ovat toki luonnollinen osa ohjelmistokehitystä.
  </p>

  <p>
    Kun ajattelemme muistin käyttöä, hajautustaululla voi olla -- tapauksesta riippuen -- pieni etu. Kun taulukko luodaan, muistista varataan heti tila koko taulukolle. Mikäli taulukon jokaiseen indeksiin ei tarvitse lisätä tietoa, on osa tästä tiedosta varattuna turhaan. Hajautustaululla taas tällaista muistin varaamista ei ennakkoon tehdä -- hajautustaulun kokoa kasvatetaan tarvittaessa.
  </p>
  

  </div>
</div>



<h1 class="material-heading">
    Vertaisarviointi: Ohjelmien testaaminen

</h1>

<div class="learning-objectives">
  <div class="learning-objectives__header">
    <i class="fa fa-user-graduate learning-objectives__icon"></i>Oppimistavoitteet
  </div>

  <div class="learning-objectives__body">
    
  <ul>
    <li>
      Harjoittelet toisten kirjoittamien testimetodien lukemista ja opit mahdollisesti lisää testaamisesta.
    </li>
  </ul>


  </div>
</div>


<p>
  Kymmenennessä osassa kirjoitimme omia testejä valmiille malliratkaisulle. Nyt on taas vertaisarvioinnin aika! Anna vertaispalautetta kahdesta jonkun toisen kurssilaisen lähettämästä tehtävästä ja arvioi lopuksi itse tekemääsi tehtävää. Itse tekemäsi tehtävä näkyy vain jos olet tehnyt sen -- jos et tehnyt tehtävää, pääset arvioimaan yhden ylimääräisen tehtävän.
</p>


<div class="hint">
  <div class="hint__header">
    <i class="fa fa-info-circle hint__icon"></i>Vertaisarviointi
  </div>

  <div class="hint__body">
    
  <p>
    Alla on kolme Crowdsorcereriin tehtyä tehtävää: kaksi jonkun kurssitoverisi lähettämää ja yksi itsearviointia varten. Niiden yhteydessä on muistin virkistykseksi ohjeistus, jonka pohjalta kyseiset tehtävänannot on tehty.
  </p>

  <p>
    Tarkastele jokaisen tehtävän tehtävänantoa ja testejä. Arvioi niiden selkeyttä, kattavuutta ja sitä, kuinka hyvin ne vastaavat valmiina annettua lähdekoodia.
  </p>

  <p>
    Palautteenannon avuksi on annettu väittämiä. Voit valita kuinka samaa mieltä niiden kanssa olet painamalla hymiöitä. Annathan myös sanallista palautetta sille varattuun kenttään! Lisää vielä tehtävää mielestäsi kuvaavia tageja ja paina Lähetä.
  </p>

  <p>
    Anna arvio kummallekin vertaispalautetehtävälle ja lopuksi vielä omallesi.
  </p>

  <p>
    Muista olla reilu ja ystävällinen. Hyvä palaute on rehellistä, mutta kannustavaa!
  </p>

  <p>
    Voit halutessasi ladata arvioitavan tehtävän tehtäväpohjan ja malliratkaisun koneellesi, ja testata niiden käyttöä. Molemmat tulevat ZIP-paketeissa, jolloin sinun täytyy purkaa ne, ennen kuin voit avata ne NetBeansissä.
  </p>


  </div>
</div>

<div class="general-callout">
  <div class="general-callout__header">
    <i class="fa fa-magic general-callout__icon"></i> Kirjoita testit valmiille malliratkaisulle 1
  </div>

  <div class="general-callout__body">
    
  <p>
    Lähdekoodin kohdalla on valmis malliratkaisu. Keksi sitä vastaava tehtävänanto ja kirjoita testit luokan Submission metodille vertaile. Lähetettyäsi tehtävän saat tiedon siitä, kääntyikö testikoodi ja menivätkö testisi läpi. Jos eivät, lue virheviesti ja lähdekoodi uudestaan ja korjaa testisi sen mukaisesti.
  </p>

  <p>
    Tehtävien luomistehtävät käsitellään pisteytyksessä bonuksena.
  </p>  


  </div>
</div>

<div class='crowdsorcerer-widget' data-assignment='17' peer-review data-exercises='3'></div>

<div class="general-callout">
  <div class="general-callout__header">
    <i class="fa fa-magic general-callout__icon"></i> Kirjoita testit valmiille malliratkaisulle 2
  </div>

  <div class="general-callout__body">
    
  <p>
    Lähdekoodin kohdalla on valmis malliratkaisu. Keksi sitä vastaava tehtävänanto ja kirjoita testit luokan Submission metodille annaKokonaisluku. Huomaa, että lähdekoodissa ei käytetä ääkkösiä.
  </p>
  <p>
    Lähetettyäsi tehtävän saat tiedon siitä, kääntyikö testikoodi ja menivätkö testisi läpi. Jos eivät, lue virheviesti ja lähdekoodi uudestaan ja korjaa testisi sen mukaisesti.
  </p>

  <p>
    Tehtävien luomistehtävät käsitellään pisteytyksessä bonuksena.
  </p>  


  </div>
</div>

<div class='crowdsorcerer-widget' data-assignment='19' peer-review data-exercises='3'></div>



<h1 class="material-heading">
    Yhteenveto

</h1>

<p>
  Yhdennessätoista osassa eli Ohjelmoinnin jatkokurssin neljännessä osassa tutustuimme geneeriseen tyyppiin sekä sen käyttöön tietorakenteissa kuten ArrayListissä ja HashMapissa, joista loimme myös omat versiot. Harjoittelimme lisäksi satunnaislukujen luomista sekä useampiulotteisten taulukoiden käyttöä. Lopuksi kertasimme lyhyesti testien kirjoittamista erityisesti muiden kirjoittamien testien lukemiseen keskittyen.
</p>

<div class="quiznator-plugin" data-quiz-id="5bf08b6afd6c3b3e161a10cc"></div>


        </div>
      </div>

      <div class="footer-wrapper">
        <footer class="footer">
  <div>
    Tämä materiaali on lisensoitu Creative Commons BY-NC-SA-lisenssillä
  </div>
  <div>
    Kurssin on tehnyt Helsingin Yliopiston Agile Education Research -tutkimusryhmä.
  </div>
    <div class="improvement">
<a href="../report_issue/" target="_blank" rel="noopener" class="btn btn-primary">    <i class="fa fa-exclamation-triangle" aria-hidden="true"></i>
    Ilmoita virhe
</a><a href="../edit_page/?path=part11.html" target="_blank" rel="noopener" class="btn btn-primary">    <i class="fa fa-pencil-alt" aria-hidden="true"></i>
    Muokkaa sivua
</a>  <a href="https://github.com/materiaalit/ohjelmointi-s18" class="footer__github-link" target="_blank" rel="noopener">
    <i class="fab fa-github"></i>
  </a>
</div>

  </div>
</footer>

      </div>
    </div>

    <div class="modal fade" id="tmc-login-modal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content">
      <form id="tmc-login-form">
        <div class="modal-header">
          <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
          <h4 class="modal-title">Kirjaudu mooc.fi -käyttäjällesi</h4>
        </div>
        <div class="modal-body">
          <div class="alert alert-info">
            Puuttuuko sinulta mooc.fi -käyttäjätunnus? <a href="https://tmc.mooc.fi/user/new" class="alert-link" target="_blank" rel="noopener">Rekisteröidy</a>
          </div>

          <div class="alert alert-danger" id="tmc-login-error" style="display: none;"></div>

          <div class="form-group">
            <label>Käyttäjätunnus tai sähköpostiosoite</label>
            <input type="text" id="tmc-login-username" class="form-control" placeholder="Käyttäjätunnus tai sähköpostiosoite"/>
          </div>

          <div class="form-group">
            <label>Salasana</label>
            <input type="password" id="tmc-login-password" class="form-control" placeholder="Salasana"/>
          </div>

          <div class="form-group">
            <label>Kurssi</label>

            <div class="form-check">
              <label class="form-check-label">
                <input type="radio" class="form-check-input" name="tmcLoginCourse" value="hy-ohpe-s18">
                Ohjelmoinnin perusteet, syksy 2018 (Helsingin yliopisto)
              </label>
            </div>

            <div class="form-check">
              <label class="form-check-label">
                <input type="radio" class="form-check-input" name="tmcLoginCourse" value="hy-ohja-s18">
                Ohjelmoinnin jatkokurssi, syksy 2018 (Helsingin yliopisto)
              </label>
            </div>

          </div>
        </div>
        <div class="modal-footer">
          <a class="btn btn-secondary" data-dismiss="modal">Sulje</a>
          <button type="submit" class="btn btn-primary">Kirjaudu sisään</button>
        </div>
      </form>
    </div>
  </div>
</div>


    <div class="table-of-contents-layer" id="table-of-contents-layer">
</div>

<div class="table-of-contents" id="table-of-contents">
  <h1 class="table-of-contents__heading">
    Sisällysluettelo
  </h1>

  <div class="table-of-contents__content">
    <ul id="table-of-contents-list"></ul>
  </div>
</div>


    <script>
  window._QUIZNATOR_ENABLED = true;
</script>

<script src="https://quiznator.mooc.fi/javascripts/plugin-loader.min.js"></script>


    <script src="https://code.jquery.com/jquery-3.1.1.min.js"
	    integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8="
	    crossorigin="anonymous"></script>

    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>

    <script src="../javascripts/scripts-77d48b13.js"></script>

    <script defer src="https://use.fontawesome.com/releases/v5.3.1/js/all.js" integrity="sha384-kW+oWsYx3YpxvjtZjFXqazFpA7UP/MbiY4jvs+RWZo2+N94PFZ36T6TFkc9O3qoB" crossorigin="anonymous"></script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.7.0/highlight.min.js"></script>

    <script>hljs.initHighlightingOnLoad();</script>

    <script src="//cdnjs.cloudflare.com/ajax/libs/cookieconsent2/3.0.1/cookieconsent.min.js"></script>
    <script src='//cdnjs.cloudflare.com/ajax/libs/diff_match_patch/20121119/diff_match_patch.js'></script>

    <script>window.cookieconsent.initialise({"palette":{"popup":{"background":"#000"},"button":{"background":"#f1d600"}}, "position": "bottom-left"});</script>

    <script src='https://materiaalit.github.io/code-states-visualizer-cdn/app.js'></script>
    <script src='https://materiaalit.github.io/typonator-cdn/app.js'></script>
    <script src='https://crowdsorcerer.testmycode.io/dist/app.js'></script>
    <script src='https://materiaalit.github.io/pdf-slideshow-cdn/app.js'></script>
    <script>
      window.initPdfSlideshow('../pdf.worker.min-7be35925.js');
    </script>
  </body>
</html>
